package org.osate.ge.internal.diagram.runtime.layout.connections.orthogonal.visibilityGraph;

import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.NavigableSet;
import java.util.Objects;
import java.util.Set;
import java.util.function.Function;

import org.osate.ge.internal.diagram.runtime.layout.connections.lineSweep.LineSweepEvent;
import org.osate.ge.internal.diagram.runtime.layout.connections.lineSweep.LineSweeper;
import org.osate.ge.internal.diagram.runtime.layout.connections.lineSweep.LineSweeper.EventType;
import org.osate.ge.internal.diagram.runtime.layout.connections.lineSweep.LineSweeperEventHandler;
import org.osate.ge.internal.diagram.runtime.layout.connections.orthogonalVisibilityGraph.test.ExampleModel;

import com.google.common.collect.TreeMultimap;

/**
 * Creates an OrthogonalSegments object based on a data source containing "interesting" horizontal and vertical segments.
 * See Wybrow M., Marriott K., Stuckey P.J. (2010) Orthogonal Connector Routing. In: Eppstein D., Gansner E.R. (eds) Graph Drawing. GD 2009.
 * Lecture Notes in Computer Science, vol 5849. Springer, Berlin, Heidelberg
 * Section 3
 *
 * The interesting segments generated by this class are not quite the same as those described in the paper. Since we are supporting hierarchical diagrams,
 * segments are generated inside elements provided by the data source. Additionally, there are cases where it is desired for connection points to generate segments
 * which extend beyond their ancestors. For this reason, parents and grandparents are ignored when generating interesting segments. However, other ancestors are
 * not ignored. An element specific segment bounds is provided by the data source to restrict the bounds of segments generated by connection points.
 *
 * Generated segments may overlap with one another.
 */
public class OrthogonalSegmentsFactory {
	public static <T> OrthogonalSegments<T> create(final OrthogonalSegmentsFactoryDataSource<T> ds) {
		final Set<VerticalSegment<T>> verticalSegments = findVerticalSegments(ds);
		final Set<HorizontalSegment<T>> horizontalSegments = findHorizontalSegments(ds);

		// Create segments object
		return new OrthogonalSegments<T>(Collections.unmodifiableSet(horizontalSegments),
				Collections.unmodifiableSet(verticalSegments));
	}

	private final static <T> Set<VerticalSegment<T>> findVerticalSegments(OrthogonalSegmentsFactoryDataSource<T> ds) {
		final List<LineSweepEvent<T>> events = createEventsForHorizontalSweep(ds);

		// Perform two horizontal line sweeps in order to get the vertical segments based on the min/max of the bounds the the location of points.
		final Set<VerticalSegment<T>> verticalSegments = new HashSet<>();
		final MinVerticalSegmentCreator<T> minVerticalCollector = new MinVerticalSegmentCreator<>(ds,
				verticalSegments);
		LineSweeper.sweep(events, minVerticalCollector.keyFunc, minVerticalCollector);

		final MaxVerticalSegmentCreator<T> maxVerticalCollector = new MaxVerticalSegmentCreator<>(ds,
				verticalSegments);
		LineSweeper.sweep(events, maxVerticalCollector.keyFunc, maxVerticalCollector);

		return verticalSegments;
	}

	/**
	 * Returns sorted events.
	 * @param ds
	 * @return
	 */
	private static <T> List<LineSweepEvent<T>> createEventsForHorizontalSweep(
			final OrthogonalSegmentsFactoryDataSource<T> ds) {
		final List<LineSweepEvent<T>> events = new ArrayList<>(ds.getElements().size() * 2); // Allocate enough events to avoid having to resize the list.
		for (final T child : ds.getElements()) {
			final Rectangle childBounds = ds.getBounds(child);
			if (childBounds.getMin().x != childBounds.getMax().x) {
				events.add(new LineSweepEvent<T>(EventType.OPEN, childBounds.getMin().x, child));
				events.add(new LineSweepEvent<T>(EventType.CLOSE, childBounds.getMax().x, child));
			} else {
				events.add(new LineSweepEvent<T>(EventType.POINT, childBounds.getMin().x, child));
			}
		}

		LineSweeper.sortByPosition(events);

		return events;
	}

	private final static <T> Set<HorizontalSegment<T>> findHorizontalSegments(
			OrthogonalSegmentsFactoryDataSource<T> ds) {
		final List<LineSweepEvent<T>> events = createEventsForVerticalSweep(ds);

		// Perform two vertical line sweeps in order to get the vertical segments based on the min/max of the bounds the the location of points.
		final Set<HorizontalSegment<T>> horizontalSegments = new HashSet<>();
		final MinHorizontalSegmentCreator<T> minHorizontalCollector = new MinHorizontalSegmentCreator<T>(ds,
				horizontalSegments);
		LineSweeper.sweep(events, minHorizontalCollector.keyFunc, minHorizontalCollector);

		final MaxHorizontalSegmentCreator<T> maxHorizontalCollector = new MaxHorizontalSegmentCreator<T>(ds,
				horizontalSegments);
		LineSweeper.sweep(events, o -> ds.getBounds(o).getMax().x, maxHorizontalCollector);

		return horizontalSegments;
	}

	/**
	 * Returns sorted events.
	 * @param ds
	 * @return
	 */
	private static <T> List<LineSweepEvent<T>> createEventsForVerticalSweep(
			final OrthogonalSegmentsFactoryDataSource<T> ds) {
		final List<LineSweepEvent<T>> events = new ArrayList<>(ds.getElements().size() * 2); // Allocate enough events to avoid having to resize the list.
		for (final T child : ds.getElements()) {
			final Rectangle childBounds = ds.getBounds(child);
			if (childBounds.getMin().y != childBounds.getMax().y) {
				events.add(new LineSweepEvent<T>(EventType.OPEN, childBounds.getMin().y, child));
				events.add(new LineSweepEvent<T>(EventType.CLOSE, childBounds.getMax().y, child));
			} else {
				events.add(new LineSweepEvent<T>(EventType.POINT, childBounds.getMin().y, child));
			}
		}

		LineSweeper.sortByPosition(events);

		return events;
	}

	/**
	 * Base line sweeper event handler which is used to process events for the various sweeps performed.
	 * Includes functionality common to all segment creators.
	 * Delegates the actual creation of segments to the child class.
	 * @param <EventTag>
	 */
	private static abstract class AbstractSegmentCreator<EventTag>
	implements LineSweeperEventHandler<EventTag, EventTag, Double> {
		protected final OrthogonalSegmentsFactoryDataSource<EventTag> ds;
		final Function<EventTag, Double> keyFunc;

		/**
		 *
		 * @param ds
		 * @param keyFunc is a function that provides the key which determines the ordering of open objects.
		 * This determines the before and after relationships of objects. For a vertical line sweep the key function should be a y value.
		 */
		public AbstractSegmentCreator(final OrthogonalSegmentsFactoryDataSource<EventTag> ds,
				final Function<EventTag, Double> keyFunc) {
			this.ds = Objects.requireNonNull(ds, "ds must not be null");
			this.keyFunc = Objects.requireNonNull(keyFunc, "keyFunc must not be null");
		}

		@Override
		public void handleEvent(final LineSweepEvent<EventTag> event,
				final TreeMultimap<Double, EventTag> openObjects) {
			final EventTag eventTag = event.tag;
			final EventTag parentTag = ds.getParent(eventTag);
			final EventTag grandparentTag = parentTag == null ? null : ds.getParent(parentTag);

			// The parent and grandparent tags are used to avoid ending a segment when it intersects with its parent.
			// The code only checks up to the grandparent level for efficiency reasons. In practice, any intersections beyond that are not
			// relevant because the segment bounds is used to prevent the segments from growing beyond that point.

			// Find the first before object which is not the event object
			EventTag before = null;
			for (final Double tmpKey : openObjects.keySet().headSet(keyFunc.apply(eventTag), true)
					.descendingSet()) {
				boolean found = false;

				final NavigableSet<EventTag> tmpObjects = openObjects.get(tmpKey);
				for (final EventTag tmp : tmpObjects) {
					if (tmp != eventTag && tmp != parentTag && tmp != grandparentTag) {
						before = tmp;
						found = true;
						break;
					}
				}

				if (found) {
					break;
				}
			}

			final Rectangle beforeBounds = before == null ? null : ds.getBounds(before);

			// Find the first after object which is not the event object
			EventTag after = null;
			for (final Double tmpKey : openObjects.keySet().tailSet(keyFunc.apply(eventTag), true)) {
				boolean found = false;
				final NavigableSet<EventTag> tmpObjects = openObjects.get(tmpKey);
				for (final EventTag tmp : tmpObjects) {
					if (tmp != eventTag && tmp != parentTag && tmp != grandparentTag) {
						after = tmp;
						found = true;
						break;
					}
				}

				if (found) {
					break;
				}
			}

			final Rectangle afterBounds = after == null ? null : ds.getBounds(after);
			createSegment(event.position, eventTag, ds.getSegmentBounds(eventTag), beforeBounds, afterBounds);
		}

		protected abstract void createSegment(final double position, final EventTag eventTag,
				final Rectangle maxSegmentBounds, final Rectangle before,
				final Rectangle after);
	}

	private static class MinVerticalSegmentCreator<EventTag> extends AbstractSegmentCreator<EventTag> {
		private final Set<VerticalSegment<EventTag>> segments;

		public MinVerticalSegmentCreator(final OrthogonalSegmentsFactoryDataSource<EventTag> ds,
				final Set<VerticalSegment<EventTag>> segments) {
			super(ds, o -> ds.getBounds(o).getMin().y);
			this.segments = Objects.requireNonNull(segments, "segments must not be null");
		}

		@Override
		protected void createSegment(final double position, final EventTag eventTag, final Rectangle maxSegmentBounds,
				final Rectangle before,
				final Rectangle after) {
			final Rectangle eventTagBounds = ds.getBounds(eventTag);
			double min = before == null ? Double.NEGATIVE_INFINITY : before.getMax().y;

			// If value is inside of before
			if (min > eventTagBounds.getMin().y) {
				min = before.getMin().y;
			}

			min = Math.max(min, maxSegmentBounds.getMin().y);

			// Clamp max since we are dealing with mins..
			final double max = Math.min(
					Math.min(after == null ? Double.POSITIVE_INFINITY : after.getMin().y, eventTagBounds.getMax().y),
					maxSegmentBounds.getMax().y);

			segments.add(new VerticalSegment<>(position, min, max, eventTag));
		}
	};

	private static class MaxVerticalSegmentCreator<EventTag> extends AbstractSegmentCreator<EventTag> {
		private final Set<VerticalSegment<EventTag>> segments;

		public MaxVerticalSegmentCreator(final OrthogonalSegmentsFactoryDataSource<EventTag> ds,
				final Set<VerticalSegment<EventTag>> segments) {
			super(ds, o -> ds.getBounds(o).getMax().y);
			this.segments = Objects.requireNonNull(segments, "segments must not be null");
		}

		@Override
		protected void createSegment(final double position, final EventTag eventTag, final Rectangle maxSegmentBounds,
				final Rectangle before,
				final Rectangle after) {
			final Rectangle eventTagBounds = ds.getBounds(eventTag);
			final double min = Math.max(
					Math.max(before == null ? Double.NEGATIVE_INFINITY : before.getMax().y, eventTagBounds.getMin().y),
					maxSegmentBounds.getMin().y);

			// Clamp max since we are dealing with mins..
			double max = after == null ? Double.POSITIVE_INFINITY : after.getMin().y;

			// If value is inside of before
			if (max < eventTagBounds.getMax().y) {
				max = after.getMax().y;
			}

			max = Math.min(max, maxSegmentBounds.getMax().y);

			segments.add(new VerticalSegment<>(position, min, max, eventTag));
		}
	};

	private static class MinHorizontalSegmentCreator<EventTag> extends AbstractSegmentCreator<EventTag> {
		private final Set<HorizontalSegment<EventTag>> segments;

		public MinHorizontalSegmentCreator(final OrthogonalSegmentsFactoryDataSource<EventTag> ds,
				final Set<HorizontalSegment<EventTag>> segments) {
			super(ds, o -> ds.getBounds(o).getMin().x);
			this.segments = Objects.requireNonNull(segments, "segments must not be null");
		}

		@Override
		protected void createSegment(final double position, final EventTag eventTag, final Rectangle maxSegmentBounds,
				final Rectangle before,
				final Rectangle after) {
			final Rectangle eventTagBounds = ds.getBounds(eventTag);
			double min = before == null ? Double.NEGATIVE_INFINITY : before.getMax().x;

			// If value is inside of before
			if (min > eventTagBounds.getMin().x) {
				min = before.getMin().x;
			}

			min = Math.max(min, maxSegmentBounds.getMin().x);

			// Clamp max since we are dealing with mins..
			final double max = Math.min(
					Math.min(after == null ? Double.POSITIVE_INFINITY : after.getMin().x, eventTagBounds.getMax().x),
					maxSegmentBounds.getMax().x);

			segments.add(new HorizontalSegment<>(position, min, max, eventTag));
		}
	};

	private static class MaxHorizontalSegmentCreator<EventTag> extends AbstractSegmentCreator<EventTag> {
		private final Set<HorizontalSegment<EventTag>> segments;

		public MaxHorizontalSegmentCreator(final OrthogonalSegmentsFactoryDataSource<EventTag> ds,
				final Set<HorizontalSegment<EventTag>> segments) {
			super(ds, o -> ds.getBounds(o).getMax().x);
			this.segments = Objects.requireNonNull(segments, "segments must not be null");
		}

		@Override
		protected void createSegment(final double position, final EventTag eventTag, final Rectangle maxSegmentBounds,
				final Rectangle before,
				final Rectangle after) {
			final Rectangle eventTagBounds = ds.getBounds(eventTag);
			final double min = Math.max(
					Math.max(before == null ? Double.NEGATIVE_INFINITY : before.getMax().x, eventTagBounds.getMin().x),
					maxSegmentBounds.getMin().x);

			// Clamp max since we are dealing with mins..
			double max = after == null ? Double.POSITIVE_INFINITY : after.getMin().x;

			// If value is inside of before
			if (max < eventTagBounds.getMax().x) {
				max = after.getMax().x;
			}

			max = Math.min(max, maxSegmentBounds.getMax().x);

			segments.add(new HorizontalSegment<>(position, min, max, eventTag));
		}
	};

	public static void main(String[] args) {
		final OrthogonalSegmentsFactoryDataSource<ExampleModel.TestElement> ds = ExampleModel.createDataSource();

		// Vertical
		final Set<VerticalSegment<ExampleModel.TestElement>> verticalSegments = findVerticalSegments(ds);
		System.out.println("Vertical Segment Count: " + verticalSegments.size());
		for (final VerticalSegment<?> vs : verticalSegments) {
			System.out.println(vs.x + " : " + vs.minY + " -> " + vs.maxY);
		}

		// Horizontal
		final Set<HorizontalSegment<ExampleModel.TestElement>> horizontalSegments = findHorizontalSegments(ds);
		System.out.println("Horizontal Segment Count: " + horizontalSegments.size());
		for (final HorizontalSegment<?> hs : horizontalSegments) {
			System.out.println(hs.getY() + " : " + hs.getMinX() + " -> " + hs.getMaxX());
		}
	}
}
