package org.osate.ge.internal.diagram.runtime.layout.connections.orthogonalVisibilityGraph.test;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;
import java.util.Objects;

import org.osate.ge.graphics.Point;
import org.osate.ge.internal.diagram.runtime.Dimension;
import org.osate.ge.internal.diagram.runtime.layout.connections.orthogonal.visibilityGraph.OrthogonalSegmentsFactoryDataSource;
import org.osate.ge.internal.diagram.runtime.layout.connections.orthogonal.visibilityGraph.Rectangle;

/**
 * Example model for use with the orthogonal visibility graph.
 * Provides a data source which provides data for experimentation and testing.
 */
public class ExampleModel {
	private static Rectangle infiniteBounds = new Rectangle(
			new Point(Double.NEGATIVE_INFINITY, Double.NEGATIVE_INFINITY),
			new Point(Double.POSITIVE_INFINITY, Double.POSITIVE_INFINITY));

	public static OrthogonalSegmentsFactoryDataSource<TestElement> createDataSource() {
		final List<TestElement> objects = new ArrayList<>();
		final TestElement root = addNonPort(objects, null, new Point(50, 50), new Dimension(700, 400));
		addNonPort(objects, root, new Point(100, 100), new Dimension(200, 200));
		addNonPort(objects, root, new Point(200, 350), new Dimension(400, 50));
		final TestElement portParent = addNonPort(objects, root, new Point(500, 100), new Dimension(200, 200));

		addPort(objects, portParent, new Point(500, 130), new Dimension(80, 80),
				new Point[] { new Point(20, 10), new Point(20, 30), new Point(20, 50) },
				new Point[] { new Point(60, 10), new Point(60, 30), new Point(60, 50) });

		final OrthogonalSegmentsFactoryDataSource<TestElement> testDataSource = new OrthogonalSegmentsFactoryDataSource<TestElement>() {
			@Override
			public List<TestElement> getElements() {
				return objects;
			}

			@Override
			public TestElement getParent(TestElement e) {
				return e.parent;
			}

			@Override
			public Rectangle getBounds(final TestElement e) {
				return e.bounds;
			}

			@Override
			public Rectangle getSegmentBounds(final TestElement e) {
				return e.segmentBounds;
			}
		};

		return testDataSource;
	}

	/**
	 * Represents a box with connection points on left and right.
	 * @param parent must not be a port
	 * @param position
	 * @param size
	 * @return
	 */
	private static TestElement addNonPort(final Collection<TestElement> elements, final TestElement parent,
			final Point position, final Dimension size) {
		final TestElement newObj = new TestElement(parent, position, size,
				parent == null ? infiniteBounds : parent.bounds);
		elements.add(newObj);

		elements.add(
				new TestElement(newObj, new Point(position.x, position.y + size.height / 2.0), newObj.segmentBounds));
		elements.add(new TestElement(newObj, new Point(position.x + size.width, position.y + size.height / 2.0),
				newObj.segmentBounds));

		return newObj;
	}

	/**
	 * Assumes that the port is on the left on its parent.
	 * @param parent
	 * @param position
	 * @param size
	 * @param exteriorConnectionPoint relative to position
	 * @param interiorConnectionPoint relative to position
	 * @return
	 */
	private static void addPort(final Collection<TestElement> elements, final TestElement parent, final Point position,
			final Dimension size, final Point[] exteriorConnectionPointPositions,
			final Point[] interiorConnectionPointPositions) {
		Objects.requireNonNull(parent, "parent must not be null");

		final TestElement newObj = new TestElement(parent, position, size, parent.bounds);
		elements.add(newObj);

		// Constrain the segment bounds of the interior and exterior ports so that the segments generated by the graph builder will be horizontal and will
		// only extend outwards in one direction. In a real implementation this would need to consider the side to which the port is docked.
		for (final Point interiorConnectionPointPosition : interiorConnectionPointPositions) {
			final Rectangle segmentBounds = new Rectangle(
					new Point(position.x + interiorConnectionPointPosition.x,
							position.y + interiorConnectionPointPosition.y),
					new Point(newObj.segmentBounds.getMax().x, position.y + interiorConnectionPointPosition.y));
			elements.add(new TestElement(newObj, new Point(position.x + interiorConnectionPointPosition.x,
					position.y + interiorConnectionPointPosition.y), segmentBounds));
		}

		final Rectangle grandparentBounds = parent.parent == null ? infiniteBounds : parent.parent.bounds;
		for (final Point exteriorConnectionPointPosition : exteriorConnectionPointPositions) {
			final Rectangle exteriorPortSegmentBounds;
			if (grandparentBounds == null) {
				exteriorPortSegmentBounds = new Rectangle(
						new Point(Double.NEGATIVE_INFINITY, position.y + exteriorConnectionPointPosition.y),
						new Point(position.x + exteriorConnectionPointPosition.x,
								position.y + exteriorConnectionPointPosition.y));
			} else {
				exteriorPortSegmentBounds = new Rectangle(
						new Point(grandparentBounds.getMin().x, position.y + exteriorConnectionPointPosition.y),
						new Point(position.x + exteriorConnectionPointPosition.x,
								position.y + exteriorConnectionPointPosition.y));
			}
			elements.add(new TestElement(newObj, new Point(position.x + exteriorConnectionPointPosition.x,
					position.y + exteriorConnectionPointPosition.y), exteriorPortSegmentBounds));
		}
	}

	public static class TestElement {
		public final TestElement parent;
		public final Rectangle bounds;
		public final Rectangle segmentBounds;

		public TestElement(final TestElement parent, final Point position, final Rectangle segmentBounds) {
			this.parent = parent;
			this.bounds = new Rectangle(position, position);
			this.segmentBounds = segmentBounds;
		}

		public TestElement(final TestElement parent, final Point position, final Dimension size,
				final Rectangle segmentBounds) {
			this.parent = parent;
			this.bounds = new Rectangle(position, new Point(position.x + size.width, position.y + size.height));
			this.segmentBounds = segmentBounds;
		}
	}
}
