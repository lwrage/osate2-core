/*
 * generated by Xtext
 */
package org.osate.xtext.aadl2.errormodel.scoping;

import org.eclipse.emf.ecore.*
import org.eclipse.xtext.EcoreUtil2
import org.osate.xtext.aadl2.errormodel.errorModel.ErrorModelSubclause
import org.osate.xtext.aadl2.errormodel.errorModel.TypeSet
import org.osate.xtext.aadl2.properties.scoping.PropertiesScopeProvider
import org.osate.xtext.aadl2.errormodel.errorModel.ErrorModelLibrary
import org.osate.xtext.aadl2.errormodel.errorModel.ErrorType
import org.osate.xtext.aadl2.errormodel.errorModel.TypeTransformationSet

/**
 * This class contains custom scoping description.
 * 
 * see : http://www.eclipse.org/Xtext/documentation/latest/xtext.html#scoping
 * on how and when to use it 
 *
 */
public class ErrorModelScopeProvider extends PropertiesScopeProvider {
	
	def String getMethodName() { // For debugging
		val StackTraceElement[] ste = Thread.currentThread().getStackTrace();
		return ste.get(2).getMethodName();
	}
	
	def Iterable<ErrorType> getErrorTypesFromLib(ErrorModelLibrary lib) {
		return (#[lib.types] + lib.extends.map[it | getErrorTypesFromLib(it)]).flatten();
	}

	def Iterable<TypeSet> getTypesetsFromLib(ErrorModelLibrary lib) {
		return (#[lib.typesets] + lib.extends.map[it | getTypesetsFromLib(it)]).flatten();
	}

	def scope_ErrorType_superType(ErrorModelLibrary context, EReference reference) {
		val errorLib = EcoreUtil2.getContainerOfType(context, ErrorModelLibrary);
		return getErrorTypesFromLib(errorLib).scopeFor(delegateGetScope(context, reference));
	}

	def scope_ErrorType_aliasedType(ErrorModelLibrary context, EReference reference) {
		val errorLib = EcoreUtil2.getContainerOfType(context, ErrorModelLibrary);
		return getErrorTypesFromLib(errorLib).scopeFor(delegateGetScope(context, reference));
	}

	def scope_TypeSet_aliasedType(ErrorModelLibrary context, EReference reference) {
		val errorLib = EcoreUtil2.getContainerOfType(context, ErrorModelLibrary);
		return getTypesetsFromLib(errorLib).scopeFor(delegateGetScope(context, reference));
	}
	
	def getErrorLibsFromContext(EObject context) {
		println(getMethodName() + ": " + context);
		var EObject parCtx;
		for (parCtx = context; parCtx != null; parCtx = parCtx.eContainer()) {
			switch (parCtx) {
				ErrorModelLibrary:
					return #[parCtx]	
				ErrorModelSubclause:
					return parCtx.useTypes	
				TypeTransformationSet:
					return parCtx.useTypes					
			}
		}
		return null;
	}

	def scope_TypeToken_type(EObject context, EReference reference) {
		println(getMethodName() + ": " + context);
		val parentScope = delegateGetScope(context, reference);
		val errorLibs = getErrorLibsFromContext(context);
		val errorTypes = (
			errorLibs.map[it | getErrorTypesFromLib(it)] +
			errorLibs.map[it | getTypesetsFromLib(it)]).flatten();
		println("Error Types: " + errorTypes.map[it | it.name].toString());
		return errorTypes.scopeFor(parentScope);
	}
}
