<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Threads</title>
   <link href="Res/styles/shared.css" rel="stylesheet" type="text/css">
   <link href="Res/styles/DynamicOutline.css" rel="stylesheet" type="text/css">
</head>
<body id="page" >

<!-- BEGIN PAGE BODY-->


<table id="pageBody">
 <col class="main">
 <col class="right">

<!-- BEGIN BREADCRUMBS-->
<tr id="breadcrumbsAndPageNavigation">
  <td class="breadcrumbs" valign="top">
<!-- BEGIN NAVIGATION BREADCRUMBS ITEM-->
<span class="breadcrumb">
   <a href="index.html">Home</a> 
   <span class="separator">&gt;</span>
</span>
<!-- END NAVIGATION BREADCRUMBS ITEM-->
<!-- BEGIN NAVIGATION BREADCRUMBS ITEM-->
<span class="breadcrumb">
   <a href="SoftwareComponents.html">5. Software Components</a> 
   <span class="separator">&gt;</span>
</span>
<!-- END NAVIGATION BREADCRUMBS ITEM-->
<!-- BEGIN NAVIGATION BREADCRUMBS HERE-->
<span class="breadcrumb">
   5.3 Threads
</span>
<!-- END NAVIGATION BREADCRUMBS HERE-->

  </td>
  <td class="pageNavigation" valign="top">
<!-- START PAGE NAVIGATION NEXT IN SEQUENCE IMAGES -->
<span class="commands">
    <span class="command">
        <img src="Res/images/previous_button.gif" alt=""> <a href="SubprogramsandSubprogramCalls.html">
        <span class="label">Previous</span></a>
    </span>
&nbsp;&nbsp;
    <span class="command">
        <a href="ThreadGroups.html">
        <span class="label">Next</span></a> <img src="Res/images/next_button.gif" alt="">
    </span>
</span>
<!-- END PAGE NAVIGATION NEXT IN SEQUENCE IMAGES  -->

  </td>
  <td class="right" valign="top">
  </td>
</tr>
<!-- END BREADCRUMBS-->

<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <div class="body">
      <div class="topicDivider">
      </div>
    </div>
  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>

<!--BEGIN PAGE BODY ITEM-->
<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <table>
      <tr class="topicHeader">
        <td class="topicImageColumn">

        </td>
        <td class="topicLineColumn">
          <a name="Topic30"></a>
          <span class=outlineNumberFirst>5.3 </span><span class=topicLineFirst>Threads</span>
          <span class="topicIcons">

          </span>
        </td>
      </tr>
    </table>

<!-- phf:Comand: Expand("BoxPartMap.mmbas") -->
     <div class="topicTextNotes"><div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread represents a sequential flow of control that executes instructions within a binary image 
produced from source text.&#160; A thread models a schedulable unit that transitions between various 
scheduling states.&#160; A thread always executes within the virtual address space of a process, i.e., 
the binary images making up the virtual address space must be loaded before any thread can 
execute in that virtual address space.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Systems 
modeled in AADL can have operational modes (see Section 11).&#160; A thread can be active 
in a particular mode and inactive in another mode.&#160; As a result a thread may transition between 
an active and inactive state as part of a mode switch.&#160; Only active threads can be dispatched and 
scheduled for execution.&#160; Threads can be dispatched periodically or as the result of explicitly 
modeled events that arrive at event ports, event data ports, or at a predeclared in event port called 
</span></font><font face="Courier New"><span>Dispatch</span></font><font face="Helvetica"><span>.&#160; 
Completion of the execution of a thread dispatch will result in an event being 
delivered through the predeclared </span></font><font face="Courier New"><span>Complete</span></font><font 
face="Helvetica"><span> event out port if it is connected.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
the thread execution results in a fault that is detected, the source text may handle the error.&#160; 
If 
the error is not handled in the source text, the thread is requested to recover and prepare for the 
next dispatch.&#160; If an error is considered thread unrecoverable, its occurrence is propagated as 
an 
event through the predeclared </span></font><font face="Courier New"><span>Error </span></font><span>out </span><font 
face="Helvetica"><span>event data port.&#160; </span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><i>Legality 
Rules</i></span></font><span></span></div>
<center>
<table border="1" width="505" align="center" cellpadding="7" style="border-collapse: collapse; border: none">
    <tr>
    <td align="center" valign="middle" width="18%" style="border: solid 0.50pt;">
    <div align="center" class="lastTableNotesDiv"><font face="Helvetica"><span><b>Category</b></span></font><span></span></div>
    </td>
    <td align="center" valign="middle" width="39%" style="border: solid 0.50pt;">
    <div align="center" class="lastTableNotesDiv"><font face="Helvetica"><span><b>Type</b></span></font><span></span></div>
    </td>
    <td align="center" valign="middle" width="43%" style="border: solid 0.50pt;">
    <div align="center" class="lastTableNotesDiv"><font face="Helvetica"><span><b>Implementation</b></span></font><span></span></div>
    </td></tr>
    <tr>
    <td align="center" valign="middle" width="18%" style="border: solid 0.50pt;">
    <div align="center" class="lastTableNotesDiv"><font color="#010101"><span><b>thread</b></span></font><span></span></div>
    </td>
    <td valign="middle" width="39%" style="border: solid 0.50pt;">
    <div align="left"><font color="#010101"><span>Features: </span></font><span></span></div>
    <ul style="margin-top: 0pt; margin-bottom: 0pt">
    <ul style="margin-top: 0pt; margin-bottom: 0pt">
    <li style="margin-left=-3mm; margin-right=0mm; padding-left=0mm; color= #010101;  ">
    <div align="left"><font color="#010101"><span>server subprogram</span></font><span> </span><span></span></div>
    </li>
    <li style="margin-left=-3mm; margin-right=0mm; padding-left=0mm; color= #010101;  "><font color="#010101"><span>port</span></font><span> </span><span></span></li>
    <li style="margin-left=-3mm; margin-right=0mm; padding-left=0mm; color= #010101;  "><font color="#010101"><span>port 
    group</span></font><span> </span><span></span></li>
    <li style="margin-left=-3mm; margin-right=0mm; padding-left=0mm; color= #010101;  "><font color="#010101"><span>provides 
    data access</span></font><span> </span><span></span></li>
    <li style="margin-left=-3mm; margin-right=0mm; padding-left=0mm; color= #010101;  "><font color="#010101"><span>requires 
    data access</span></font><span> </span><span></span></li>
    </ul>
    </ul>
    <div align="left"><font color="#010101"><span>Flow specifications: yes</span></font><span></span></div>
    <div align="left" class="lastTableNotesDiv"><font color="#010101"><span>Properties: yes</span></font><span></span></div>
    </td>
    <td valign="middle" width="43%" style="border: solid 0.50pt;">
    <div align="left"><font color="#010101"><span>Subcomponents:</span></font><span></span></div>
    <ul style="margin-top: 0pt; margin-bottom: 0pt">
    <ul style="margin-top: 0pt; margin-bottom: 0pt">
    <li style="margin-left=-3mm; margin-right=0mm; padding-left=0mm; color= #010101;  ">
    <div align="left"><font color="#010101"><span>data</span></font><span> </span><span></span></div>
    </li>
    </ul>
    </ul>
    <div align="left"><font color="#010101"><span>Subprogram calls: yes</span></font><span></span></div>
    <div align="left"><font color="#010101"><span>Connections: yes</span></font><span></span></div>
    <div align="left"><font color="#010101"><span>Flows: yes</span></font><span></span></div>
    <div align="left"><font color="#010101"><span>Modes: yes</span></font><span></span></div>
    <div align="left" class="lastTableNotesDiv"><font color="#010101"><span>Properties: yes</span></font><span></span></div>
    </td></tr>
</table>
</center>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><br/>
</div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread type declaration can contain port, port group, server subprogram declarations as well as 
requires and provides data access declarations.&#160; It can also contain a flow specifications and 
property associations.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread component implementation can contain data declarations, a calls subclause, a flows 
subclause, a modes subclause, and thread property associations.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread or any of its features may not contain an explicit </span></font><font face="Courier New"><span>Dispatch</span></font><font 
face="Helvetica"><span> <b>in</b> event or event data port 
declaration, nor a </span></font><font face="Courier New"><span>Complete</span></font><font face="Helvetica"><span> 
or </span></font><font face="Courier New"><span>Error</span></font><font face="Helvetica"><span> <b>out</b> 
event or event data port declaration.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The </span></font><font 
face="Courier New"><span>Compute_Entrypoint</span></font><font face="Helvetica"><span> property must 
have a value that indicates the source code to 
execute after a thread has been dispatched.&#160; Other entrypoint properties are optional, i.e., if 
a 
property value is not defined, then the entrypoint is not called. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The </span></font><font 
face="Courier New"><span>Period</span></font><font face="Helvetica"><span> property must have a value 
if the </span></font><font face="Courier New"><span>Dispatch_Protocol</span></font><font face="Helvetica"><span> 
property value is 
</span></font><font face="Courier New"><span>periodic</span></font><font face="Helvetica"><span> or </span></font><font 
face="Courier New"><span>sporadic</span></font><font face="Helvetica"><span>.</span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><i>Standard 
Properties</i></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
Properties related to source text</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Source_Text: <b>inherit</b> <b>list 
of aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Source_Language: 
Supported_Source_Languages </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
Properties specifying memory requirements of threads</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Source_Code_Size: 
Size</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Source_Data_Size: 
Size</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Source_Stack_Size: 
Size</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Source_Heap_Size: 
Size </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
Properties specifying thread dispatch properties</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Dispatch_Protocol: 
Supported_Dispatch_Protocols</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Period: 
inherit Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
the default value of the deadline is that of the period</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Deadline: 
Time =&gt; <b>inherit</b> <b>value(Period)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
Properties specifying execution entrypoints and timing constraints</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Initialize_Execution_Time: 
Time_Range</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Initialize_Deadline: 
Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Initialize_Entrypoint: <b>aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Compute_Execution_Time: 
Time_Range</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Compute_Deadline: 
Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Compute_Entrypoint: <b>aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Activate_Execution_Time: 
Time_Range</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Activate_Deadline: 
Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Activate_Entrypoint: <b>aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Deactivate_Execution_Time: 
Time_Range</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Deactivate_Deadline: 
Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Deactivate_Entrypoint: <b>aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Recover_Execution_Time: 
Time_Range</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Recover_Deadline: 
Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Recover_Entrypoint: <b>aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Finalize_Execution_Time: 
Time_Range</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Finalize_Deadline: 
Time</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Finalize_Entrypoint: <b>aadlstring</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
Properties specifying constraints for processor and memory binding</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Allowed_Processor_Binding_Class: </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>&#160;&#160; <b>inherit</b> <b>list</b> <b>of</b> <b>classifier</b> 
(processor,<b> system)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Allowed_Processor_Binding: <b>inherit</b> <b>list</b> <b>of</b> <b>reference</b> 
(processor,<b> 
system)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Allowed_Memory_Binding_Class: </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>&#160;&#160; <b>inherit</b> <b>list</b> <b>of</b> 
classifier<b> (memory, system, processor)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Allowed_Memory_Binding: <b>inherit 
list</b> <b>of</b> <b>reference</b> (memory,<b> system, 
processor)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Not_Collocated: <b>list</b> <b>of</b> <b>reference</b> 
(data, <b>thread,</b> <b>process,</b> <b>system, 
connections)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Allowed_Connection_Binding_Class: </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>&#160;&#160; <b>inherit</b> <b>list</b> <b>of</b> <b>classifier(processor,</b> <b>bus, 
device)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Allowed_Connection_Binding: <b>inherit</b> <b>list</b> <b>of</b> <b>reference</b> 
(bus,<b> processor, 
device)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Actual_Connection_Binding: <b>inherit</b> <b>reference</b> 
(bus,<b> processor,</b> <b>device)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
Binding value filled in by binding tool</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Actual_Processor_Binding: <b>inherit</b> <b>reference</b> 
(processor)</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Actual_Memory_Binding: <b>inherit</b> <b>reference</b> 
(memory)</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
property indicating whether the thread affects the hyperperiod </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
for mode switching</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Synchronized_Component: <b>inherit</b> <b>aadlboolean </b>=&gt; <b>true</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>-- 
property specifying the action for executing thread at actual mode 
switch</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Active_Thread_Handling_Protocol: </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>&#160;&#160; 
inherit<b> </b>Supported_Active_Thread_Handling_Protocols</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
=&gt; <b>value(Default_Active_Thread_Handling_Protocol)</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span>Active_Thread_Queue_Handling_Protocol: </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Courier New" color="#010101"><span><b>&#160;&#160; 
inherit</b> enumeration (flush, hold) =&gt; flush</span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><i>Semantics</i></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Thread 
semantics are described in terms of thread states, thread dispatching, thread scheduling 
and execution, and fault handling.&#160; Thread execution semantics apply once the appropriate binary 
images have been loaded into the respective virtual address space (see Section 5.5).</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Threads 
may be part of modes of containing components. In that case a thread is active, i.e., 
eligible for dispatch and scheduling, only if the thread is part of the current mode.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Threads 
can contain mode subclauses that define thread-internal operational modes. Threads can 
have property values that are different for different thread-internal modes.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Every 
thread has a predeclared <b>in event port</b> named </span></font><font face="Courier New"><span>Dispatch</span></font><font 
face="Helvetica"><span>.&#160; If this port is connected, i.e., 
named as the destination in a connection declaration, then the arrival of an event results in the 
dispatch of the thread. If the </span></font><font face="Courier New"><span>Dispatch</span></font><font 
face="Helvetica"><span> port is connected, then the arrival of an event on an 
explicitly declared event ports or event data ports will result in the queuing of the event or event 
data without causing a thread dispatch. When the </span></font><font face="Courier New"><span>Dispatch</span></font><font 
face="Helvetica"><span> port is connected, only events 
arriving at this port will cause a thread to be dispatched.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Periodic 
threads ignore any events arriving through explicitly declared event or event data 
connections or through an event connection to the </span></font><font face="Courier New"><span>Dispatch</span></font><font 
face="Helvetica"><span> port.&#160; Periodic thread dispatches 
are solely determined by the clock according to the time interval specified through the </span></font><font 
face="Courier New"><span>Period</span></font><font face="Helvetica"><span> 
property value.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Every 
thread has a predeclared <b>out event port </b>named </span></font><font face="Courier New"><span>Complete</span></font><font 
face="Helvetica"><span>.&#160; If this port is connected, i.e., 
named as the source in a connection declaration, then an event is raised implicitly on this port 
when the execution of a thread dispatch completes. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Every 
thread has a predeclared <b>out event data port </b>named </span></font><font face="Courier New"><span>Error</span></font><font 
face="Helvetica"><span>.&#160; If this port is connected, 
i.e., named as the source in a connection declaration, then an event is raised implicitly on this 
port when a thread unrecoverable error is detected.&#160; This supports the propagation of thread 
unrecoverable errors as event data for fault handling by a thread.&#160; The source text implementing 
the fault handling thread may map the error represented by event data into an event that can 
trigger a mode switch through a </span></font><font face="Courier New"><span>Raise_Event</span></font><font 
face="Helvetica"><span> call in its source text.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>NOTES: </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica" size="1"><span 
style="font-size:9pt">Mode transitions can only refer to event ports as their trigger. This means that </span></font><font 
face="Courier New" size="1"><span style="font-size:9pt">Error</span></font><font face="Helvetica" size="1"><span 
style="font-size:9pt"> ports cannot be 
directly connected to mode transitions. Instead, they have to be connected to a thread whose source 
text 
interprets the data portion to identify the error type and then raise an appropriate event through an 
out 
event port that triggers the appropriate mode transition.&#160; Such a thread typically plays the role 
of a 
system health monitor that makes system reconfiguration decisions based on the nature and frequency 
of detected faults.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Thread 
States and Actions</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread executes a code sequence in the associated source text when dispatched and 
scheduled to execute.&#160; This code sequence is part of a binary image accessible in the virtual 
address space of the containing process.&#160; It is assumed that the process is bound to the memory 
that contains the binary image (see Section 5.5).&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread goes through several states.&#160; Thread state transitions under normal operation are 
described here and illustrated in Figure 5.&#160; Thread state transitions under fault conditions are 
described in the <b>Execution Fault Handling</b> section below.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The 
initial state is <i>thread halted</i>. When the loading of the virtual address space as declared by 
the 
enclosing process completes (see Section 5.5), a thread is <i>initialized</i> by performing an 
initialization code sequence in the source text.&#160; Once initialization is completed the thread enters 
the <i>suspended awaiting dispatch</i> state if the thread is part of the initial mode, otherwise it 
enters 
the <i>suspended awaiting mode</i> state.&#160; When a thread is in the <i>suspended awaiting mode</i> 
state it 
cannot be dispatched for execution.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>When 
a mode switch is initiated, a thread that is part of the old mode and not part of the new 
mode <i>exits</i> the mode by transitioning to the <i>suspended awaiting mode</i> state after performing 
<i>thread deactivation </i>during the<i> mode change in progress </i>system<i>&#160;</i> state (see 
Figure 18).&#160; If the 
thread is periodic and its </span></font><font face="Courier New"><span>Synchronized_Component</span></font><font 
face="Helvetica"><span> property is true, then its period is taken 
into consideration to determine the actual mode switch time (see Sections 11 and 12.3 for 
detailed timing semantics of a mode switch). If an aperiodic or a sporadic thread is executing a 
dispatch when the mode switch is initiated, its execution is handled according to the 
</span></font><font face="Courier New"><span>Active_Thread_Handling_Protocol</span></font><font face="Helvetica"><span> 
property. A thread that is not part of the old mode and 
part of the new mode <i>enters</i> the <i>mode</i> by transitioning to the <i>suspended awaiting dispatch</i> 
state 
after performing <i>thread activation</i>.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>When 
in the <i>suspended awaiting dispatch</i> state, a thread is awaiting a dispatch request for 
performing the execution of a compute source text code sequence as specified by the 
</span></font><font face="Courier New"><span>Compute_Entrypoint</span></font><font face="Helvetica"><span> 
property.&#160; When a dispatch request is received for a thread, data, event 
information, and event data is made available to the thread through its port variables (see Sections 
8.1 and 9.1.1).&#160; The thread is then handed to the scheduler to perform the computation.&#160; Upon 
successful completion of the computation, the thread returns to the <i>suspended</i> <i>awaiting dispatch</i> 
state.&#160; If a dispatch request is received for a thread while the thread is in the compute state, 
this 
dispatch request is handled according to the specified </span></font><font face="Courier New"><span>Overflow_Handling_Protocol</span></font><font 
face="Helvetica"><span> for the 
event or event data port of the thread.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread may enter the <i>thread halted</i> state, i.e., will not be available for future dispatches and 
will 
not be included in future mode switches. If re-initialization is requested for a thread in the <i>thread 
halted </i>state (see Section 5.5), then its virtual address space is reloaded, the processor to which 
the thread is bound is restarted, or the system instance is restarted.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread may be requested to enter its <i>thread halted</i> state through a <i>stop</i> request after 
completing the execution of a dispatch or while not part of the active mode. In this case, the 
thread may execute a <i>finalize</i> entrypoint before entering the <i>thread halted</i> state. A thread 
may 
also enter the <i>thread halted</i> state immediately through an <i>abort</i> request.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Figure 
5 presents the top-level hybrid automaton (using the notation defined in Section 1.6) to 
describe the dynamic semantics of a thread.&#160; Two succeeding figures elaborate on the 
</span></font><font face="Courier New"><span>Performing</span></font><font face="Helvetica"><span> substate 
(Figure 6 and </span></font><font face="Helvetica" color="#010101"><span>Figure 7</span></font><font 
face="Helvetica"><span>).&#160; The bold faced edge labels in Figure 5 indicate 
that the transitions marked by the label are coordinated across multiple hybrid automata.&#160; The 
scope of the labels is indicated in parentheses, i.e., interaction with the process hybrid 
automaton (Figure 8) and with system wide mode switching (see Section 12.1).&#160; The hybrid 
automata contain assertions. In a time-partitioned system these assertions will be satisfied. In 
other systems they will be treated as anomalous behavior.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
each of the states representing a <i>performing thread action</i> such as initialize, compute, 
recover, activate, deactivate, and finalize, an execution entrypoint to a code sequence in the 
source text can be specified.&#160; Each entrypoint may refer to a different source text code sequence 
which contains the entrypoint, or all entrypoints of a thread may be contained in the same source 
text code sequence. In the latter case, the source text code sequence can determine the context 
of the execution through a </span></font><font face="Courier New"><span>Dispatch_Status</span></font><font 
face="Helvetica"><span> runtime service call (see <b>Runtime Support</b>).&#160; 
The execution semantics for these entrypoints is described in the <b>Thread Scheduling and 
Execution </b>section that follows.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>An <i>initialize 
entrypoint</i> is executed once during system initialization and allows threads to perform 
application specific initialization, such as insuring the correct initial value of its <b>out</b> and <b>in 
out</b> 
ports. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The <i>activate</i> 
and<i> deactivate entrypoints</i>&#160; are executed during mode transitions and allow threads 
to take user-specified actions to save and restore application state for continued execution 
between mode switches.These entrypoints may be used to reinitialize application state due to a 
mode transition.&#160; Activate entrypoints can also ensure that <b>out</b> and <b>in out</b> ports 
contain correct 
values for operation in the new mode.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The <i>compute 
entrypoint</i> represents the code sequence to be executed on every thread dispatch. 
Each server subprogram represents a separate compute entrypoint of the thread. Server 
subprogram calls are thread dispatches to the respective entrypoint.&#160; Event ports and event data 
ports can have port specific compute entrypoints to be executed when the corresponding event or 
event data dispatches a thread.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A <i>recover 
entrypoint</i> is executed when a fault in the execution of a thread requires recovery 
activity to continue execution. This entrypoint allows the thread to perform fault recovery actions 
(for a detailed description see the <b>Execution Fault Handling</b> section below).&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A<i> 
finalize entrypoint </i>is executed when a thread is asked to terminate as part of a process unload 
or process stop.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
no value is specified for any of the entrypoints, execution is considered as immediately 
completed without consumption of execution time.</span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><img src="NotesImages/Topic30NotesImage12.jpg" align="bottom" width="595" height="717" border="0" alt="graphic" /></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Figure 
5 Thread States and Actions</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Thread 
Dispatching</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The </span></font><font 
face="Courier New"><span>Dispatch_Protocol</span></font><font face="Helvetica"><span> property of a 
thread determines the characteristics of dispatch 
requests to the thread.&#160; This is modeled in the hybrid automaton in Figure 5 by the </span></font><font 
face="Courier New"><span>Enabled(t)</span></font><font face="Helvetica"><span> 
function and the </span></font><font face="Courier New"><span>Wait_For_Dispatch</span></font><font face="Helvetica"><span> 
invariant. The </span></font><font face="Courier New"><span>Enabled</span></font><font face="Helvetica"><span> 
function determines when a 
transition to performing thread computation will occur.&#160; The </span></font><font face="Courier New"><span>Wait_For_Dispatch</span></font><font 
face="Helvetica"><span> invariant 
captures the condition under which the </span></font><font face="Courier New"><span>Enabled</span></font><font 
face="Helvetica"><span> function is evaluated. The consequence of a 
dispatch is the execution of the entrypoint source text code sequence at its <i>current execution</i> 
position.&#160; This position is set to the first step in the code sequence and reset upon completion 
(see <b>Thread Scheduling and Execution</b> below).</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
a thread whose dispatch protocol is </span></font><font face="Courier New"><span>periodic</span></font><font 
face="Helvetica"><span>, a dispatch request is issued at time intervals 
of the specified </span></font><font face="Courier New"><span>Period</span></font><font face="Helvetica"><span> 
property value.&#160; The </span></font><font face="Courier New"><span>Enabled</span></font><font face="Helvetica"><span> 
function is </span></font><font face="Courier New"><span>t = Period</span></font><font face="Helvetica"><span>. 
The 
</span></font><font face="Courier New"><span>Wait_For_Dispatch</span></font><font face="Helvetica"><span> 
invariant is </span></font><font face="Courier New"><span>t </span></font><font face="Symbol"><span>£</span></font><font 
face="Courier New"><span> Period</span></font><font face="Helvetica"><span>.&#160; The dispatch occurs 
at </span></font><font face="Courier New"><span>t = Period</span></font><font face="Helvetica"><span>. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
a thread whose dispatch protocol is </span></font><font face="Courier New"><span>sporadic</span></font><font 
face="Helvetica"><span>, a dispatch request is the result of an event or 
event data arriving at an event or event data port of the thread, or a remote subprogram call arriving 
at a server subprogram feature of the thread.&#160; The time interval between successive dispatch 
requests will never be less than the associated </span></font><font face="Courier New"><span>Period</span></font><font 
face="Helvetica"><span> property value.&#160; The 
</span></font><font face="Courier New"><span>Overflow_Handling_Protocol </span></font><span>property 
for event ports specifies the action to take when 
e</span><font face="Helvetica"><span>vents arrive too frequently, i.e., the time between successive 
events is less than what is 
specified in the associated </span></font><font face="Courier New"><span>Period </span></font><font 
face="Helvetica"><span>property. These events are either ignored, queued until the 
end of the period (and then dispatched), or are treated as an error. The </span></font><font face="Courier New"><span>Enabled</span></font><font 
face="Helvetica"><span> function is </span></font><font face="Courier New"><span>t &#8805; 
Period</span></font><font face="Helvetica"><span>. The </span></font><font face="Courier New"><span>Wait_For_Dispatch</span></font><font 
face="Helvetica"><span> invariant is </span></font><font face="Courier New"><span>true</span></font><font 
face="Helvetica"><span>.&#160; The dispatch actually occurs when the 
guard on the dispatch transition is true and a dispatch request arrives in the form of an event at an 
event port with an empty queue, or an event is already queued when the guard becomes true, or a 
remote subprogram call arrives when the guard is true.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
a thread whose dispatch protocol is </span></font><font face="Courier New"><span>aperiodic</span></font><font 
face="Helvetica"><span>, a dispatch request is the result of an event 
or event data arriving at an event or event data port of the thread, or a remote subprogram call 
arriving at a server subprogram feature of the thread.&#160; There is no constraint on the inter-arrival 
time of events, event data or remote subprogram calls.&#160; The </span></font><font face="Courier New"><span>Enabled</span></font><font 
face="Helvetica"><span> function is </span></font><font face="Courier New"><span>true</span></font><font 
face="Helvetica"><span>.&#160; The 
</span></font><font face="Courier New"><span>Wait_For_Dispatch</span></font><font face="Helvetica"><span> 
invariant is </span></font><font face="Courier New"><span>true</span></font><font face="Helvetica"><span>.&#160; 
The dispatch actually occurs immediately when a 
dispatch request</span></font><font face="Courier New"><span> </span></font><font face="Helvetica"><span>arrives 
in the form of an event at an event port with an empty queue, or if an 
event is already queued when a dispatch execution completes, or a remote subprogram call 
arrives.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
several events or event data occur logically simultaneously and are routed to the same port of 
an </span></font><font face="Courier New"><span>aperiodic</span></font><font face="Helvetica"><span> 
or </span></font><font face="Courier New"><span>sporadic</span></font><font face="Helvetica"><span> 
thread, the order of arrival for the purpose of event handling 
according the above rules is implementation-dependent.&#160; If several events or event data occur 
logically simultaneously and are routed to the different ports of the same </span></font><font face="Courier New"><span>aperiodic</span></font><font 
face="Helvetica"><span> or 
</span></font><font face="Courier New"><span>sporadic</span></font><font face="Helvetica"><span> thread, 
the order of event handling is determined by the </span></font><font face="Courier New"><span>Urgency</span></font><font 
face="Helvetica"><span> property associated 
with the ports.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
a thread whose dispatch protocol is </span></font><font face="Courier New"><span>background</span></font><font 
face="Helvetica"><span>, the thread is dispatched immediately 
upon completion of its initialization entrypoint execution.&#160; The </span></font><font face="Courier New"><span>Enabled</span></font><font 
face="Helvetica"><span> function is </span></font><font face="Courier New"><span>true</span></font><font 
face="Helvetica"><span>.&#160; The 
</span></font><font face="Courier New"><span>Wait_For_Dispatch</span></font><font face="Helvetica"><span> 
invariant is </span></font><font face="Courier New"><span>t = 0</span></font><font face="Helvetica"><span>.&#160; 
The dispatch occurs immediately.&#160; Note that 
background threads do not have their current execution position reset on a mode switch. In other 
words, the background thread will resume execution from where it was previously suspended due 
to a mode switch.&#160; A background thread is scheduled to execute such that all other threads&#146; 
timing requirements are met. If more than one background thread is dispatched, the processor&#146;s 
scheduling protocol determines how such background threads are scheduled.&#160; For example, a 
FIFO protocol for background threads means that one background thread at a time is executed, 
while fair share means that all background threads will make progress in their execution.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Thread 
Scheduling and Execution</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>When 
a thread action is <i>computation</i>, the execution of the thread&#146;s entrypoint source text code 
sequence is managed by a scheduler.&#160; This scheduler coordinates all thread executions on one 
processor as well as concurrent access to shared resources.&#160; While performing the execution of 
an entrypoint the thread can <i>execute nominally</i> or <i>execute recovery</i> (see </span></font><font 
face="Helvetica" color="#010101"><span>Figure 7</span></font><font face="Helvetica"><span>). While 
<i>executing</i> an entrypoint a thread can be in one of five substates: ready, running, awaiting 
resource, awaiting return, and awaiting resume (see Figure 6).</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread initially enters the <i>ready</i> state.&#160; A scheduler selects one thread from the set of 
threads in 
the ready state to run on one processor according to a specified scheduling protocol.&#160; It ensures 
that only one thread is in the <i>running</i> state on a particular processor.&#160; If no thread is 
in the ready 
state, the processor is idle until a thread enters the ready state.&#160; A thread will remain in the 
running state until it completes execution of the dispatch, until a thread entering the ready state 
preempts it if the specified scheduling protocol prescribes preemption, until it blocks on a shared 
resource, or until an error occurs.&#160; In the case of completion, the thread transitions to the 
suspended <i>awaiting dispatch</i> state, ready to service another dispatch request.&#160; In the case 
of 
preemption, the thread returns to the ready state.&#160; In the case of resource blocking, it transitions 
to the <i>awaiting resource</i> state.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Resource 
blocking can occur when two threads attempt to access shared data.&#160; Such access is 
performed in a critical region.&#160; When a thread enters a critical region a </span></font><font face="Courier New"><span>Get_Resource</span></font><font 
face="Helvetica"><span> operation 
is performed on the shared data component.&#160; Upon exit from a critical region a 
</span></font><font face="Courier New"><span>Release_Resource</span></font><font face="Helvetica"><span> 
operation is performed.&#160; A </span></font><font face="Courier New"><span>Concurrency_Control_Protocol</span></font><font 
face="Helvetica"><span> property 
value associated with the shared data component determines the particular concurrency control 
mechanism to be used (see Section 5.1).&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
running thread may require access to shared resources such as shared data components 
through a critical region.&#160; Such access is coordinated through a concurrency control mechanism 
that implements the specified concurrency control protocol. These mechanisms may be blocking 
such as the use of a semaphore or non-blocking such as non-preemption through priority ceiling 
protocol.&#160; In the case of a blocking mechanism, a thread entering a critical region (via 
</span></font><font face="Courier New"><span>Get_Resource</span></font><font face="Helvetica"><span>) 
may be blocked and enter the <i>awaiting resource </i>state.&#160; The thread transitions 
out of the awaiting resource state into the ready state when another thread exits the critical region 
(via </span></font><font face="Courier New"><span>Release_Resource</span></font><font face="Helvetica"><span>).&#160; 
Multiple threads may block trying to gain access to the same 
resource; such access is mediated by the specified concurrency coordination protocol (see 
Section 5.1).&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The 
time a thread resides in a critical region, i.e., the time it may block other threads from 
entering the critical region, in worst case is the duration of executing one thread dispatch.&#160; 
This 
time may be reduced by specifying a call sequence within a thread and indicating the 
subprogram(s) that require access to shared data, i.e., have to execute in a critical region.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>When 
a thread completes execution it is assumed that all critical regions have been exited, i.e., 
access control to shared data has been released.&#160; Otherwise, the execution of the thread is 
considered erroneous.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Subprogram 
calls to server subprograms are synchronous.&#160; A thread in the running state enters 
the <i>awaiting return</i> state when performing a call to a subprogram whose service is performed by 
a 
server subprogram in another thread.&#160; The service request for the execution of the subprogram is 
transferred to the server subprogram request queue of a thread as specified by the 
</span></font><font face="Courier New"><span>Actual_Subprogram_Call</span></font><font face="Helvetica"><span> 
property that specifies the binding of the subprogram call to a 
server subprogram feature in another thread.&#160; When the thread executing the corresponding server 
subprogram completes and the result is available to the caller, the thread with the calling 
subprogram transitions to the ready state.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
background thread may be temporarily suspended by a mode switch in which the thread is not 
part of the new mode, as indicated by the <b>exit(Mode)</b> in Figure 6.&#160; In this case, the thread 
transitions to the <i>awaiting resume </i>state.&#160; If the thread was in a critical region, it will 
be suspended 
once it exits the critical region.&#160; A background thread resumes execution when it becomes part 
of 
the current mode again in a later mode switch.&#160; It then transitions from the awaiting resume state 
into the ready state.&#160; A background thread must be allowed to exit any critical region before it 
can 
be suspended as result of a mode switch.</span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><img src="NotesImages/Topic30NotesImage15.jpg" align="bottom" width="622" height="413" border="0" alt="graphic" /></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Figure 
6 Thread Scheduling and Execution States</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Execution 
of any of these entrypoints is characterized by actual execution time (<i>c</i>) and by 
elapsed time (<i>t</i>).&#160; Actual execution time is the time accumulating while a thread actually 
runs on 
a processor.&#160; Elapsed time is the time accumulating as real time since the arrival of the dispatch 
request.&#160; Accumulation of time for <i>c</i> and <i>t</i> is indicated by their first derivatives </span></font><font 
face="Symbol"><span>d</span></font><font face="Helvetica"><span><i>c</i> and </span></font><font face="Symbol"><span>d</span></font><font 
face="Helvetica"><span><i>t</i>.&#160; A 
derivative value of 1 indicates time accumulation and a value of 0 no accumulation.&#160; Figure 6 
shows the derivative values for each of the scheduling states.&#160; A thread accumulates actual 
execution time only while it is in the running state.&#160; The processor time, if any, required to 
switch 
a thread between the running state and any of the other states, which is specified in the 
</span></font><font face="Courier New"><span>Thread_Swap_Execution_Time</span></font><font face="Helvetica"><span> 
property of the processor, is not accounted for in the 
</span></font><font face="Courier New"><span>Compute_Execution_Time</span></font><font face="Helvetica"><span> 
property, but must be accounted for by an analysis tool.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The 
execution time and elapsed time for each of the entrypoints are constrained by the entrypoint-
&#160;specific </span></font><font face="Courier New"><span>&lt;entrypoint&gt;_Execution_Time </span></font><font 
face="Helvetica"><span>and entrypoint-specific 
</span></font><font face="Courier New"><span>&lt;entrypoint&gt;_Deadline</span></font><font face="Helvetica"><span> 
properties specified for the thread.&#160; If no entrypoint specific 
execution time or deadline is specified, those of the containing thread apply.&#160; There are three 
timing constraints:</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Actual 
execution time, <i>c</i>, will not exceed the maximum entrypoint-specific execution time. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Upon 
execution completion the actual execution time, <i>c</i>, will have reached at least the minimum 
entrypoint-specific execution time.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Elapsed 
time, <i>t</i>, will not exceed the entrypoint-specific deadline.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Execution 
of a thread is considered anomalous when the timing constraints are violated. Each 
timing constraint may be enforced and reported as an error at the time, or it may be detected after 
the violation has occurred and reported at that time.&#160; An implementation must document its 
handling of timing constraints.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Execution 
Fault Handling</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
fault is defined to be an anomalous undesired change in thread execution behavior, possibly 
resulting from an anomalous undesired change in data being accessed by that thread or from 
violation of a compute time or deadline constraint.&#160; An error is a fault that is detected during 
operation and is not handled as part of normal execution by that thread.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Detectable 
errors may be classified as <i>thread recoverable</i> errors, or <i>thread unrecoverable</i> errors. 
In the case of a thread recoverable<i> </i>error, the thread can recover and continue with the next 
dispatch. Thread unrecoverable errors can be communicated as events and handled as thread 
dispatches or mode changes.&#160; Alternatively, these errors may be reported as event data and 
communicated to an error handling thread for further analysis and recovery actions.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
thread recoverable errors, the thread affected by the error is given a chance to recover through 
the invocation of the thread&#146;s recover entrypoint.&#160; The recover entrypoint source text sequence 
has 
the opportunity to update the thread&#146;s application state.&#160; Upon completion of the recover 
entrypoint execution, the performance of the thread&#146;s dispatch is considered complete.&#160; In 
the 
case of performing thread computation, this means that the thread transitions to the suspended 
await dispatch state (see Figure 5), ready to perform additional dispatches.&#160; Concurrency control 
on any shared resources must be released.&#160; This thread-level fault handling behavior is illustrated 
in </span></font><font face="Helvetica" color="#010101"><span>Figure 7</span></font><font face="Helvetica"><span>.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>In 
the presence of a thread recoverable error, the maximum interval of time between the dispatch 
of a thread and its returning to the suspensed awaiting dispatch state is the sum of the thread&#146;s 
compute deadline and its recover deadline. The maximum execution time consumed is the sum of 
the compute execution time and the recover execution time. In the case when an error is 
encountered during recovery, the same numbers apply. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
thread unrecoverable error causes the execution of a thread to be terminated prematurely 
without undergoing recovery.&#160; The thread unrecoverable error is reported as an error event through 
the predeclared </span></font><font face="Courier New"><span>Error</span></font><font face="Helvetica"><span> 
event data port, if that port is connected.&#160; If this implicit error port is not 
connected, the error is not propagated and other parts of the system will have to recognize the 
fault through their own observations.&#160; In the case of a thread unrecoverable error, the maximum 
interval between the dispatch of the thread and its returning to the suspensed awaiting dispatch 
state is the compute deadline, and the maximum execution time consumed is the compute 
execution time.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
errors detected by the runtime system, error details are recorded in the data portion of the 
event as specified by the implementation.&#160; For errors detected by the source text, the application 
can choose its encoding of error detail and can raise an event in the source text.&#160; If the 
propagated error will be used to directly dispatch another thread or trigger a mode change, only 
an event needs to be raised.&#160; If the recovery action requires interpretation external to the raising 
thread, then an event with data must be raised. The receiving thread that is triggered by the event 
with data can interpret the error data portion and raise events that trigger the intended mode 
transition.</span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><img src="NotesImages/Topic30NotesImage16.jpg" align="bottom" width="616" height="410" border="0" alt="graphic" /></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica" color="#010101"><span><b>Figure 
7 Performing Thread Execution with Recovery</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
fault may be detected by the source text runtime system or by the application itself.&#160; Detection 
of a fault in the source text runtime system can result in an exception that is caught and handled 
within the source text.&#160; The source text exception handler may propagate the error&#160; to an 
external 
handler by raising an event or an event with data.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>For 
errors encountered by the source text runtime system, the error class is defined by the 
developer.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
timing fault during initialize, compute, activation, and deactivation entrypoint executions is 
considered to be a thread recoverable error.&#160; A timing fault during recover entrypoint execution 
is 
considered to be a thread unrecoverable error.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
any error is encountered while a thread is executing a recover entrypoint, it is treated as a 
thread unrecoverable error, as predefined for the runtime system.&#160; In other words, an error during 
recovery must not cause the thread to recursively re-enter the executing recovery state.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
a fault is encountered by the application source text itself, it may explicitly raise an error 
through a </span></font><font face="Courier New"><span>Raise_Error</span></font><font face="Helvetica"><span> 
service call on the </span></font><font face="Courier New"><span>Error </span></font><font face="Helvetica"><span>port 
with the error class as parameter.&#160; This 
service call may be performed in the source text of any entrypoint.&#160; In the case of recovery 
entrypoints, the error class must be <i>thread unrecoverable</i>.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Faults 
may also occur in the execution platform. They may be detected by the execution platform 
components themselves and reported through an event or event data port, as defined by the 
execution platform component.&#160; They may go undetected until an application component such as 
a health monitoring thread detects missing health pulse events, or a periodic thread detects 
missing input.&#160; Once detected, such errors can be handled locally or reported as event data.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>System 
Synchronization Requirements</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>An 
application system may consist of multiple threads.&#160; Each thread has its own hybrid 
automaton state with its own <i>c</i> and <i>t</i> variables.&#160; This results in a set of concurrent 
hybrid 
automata.&#160; In the concurrent hybrid automata model for the complete system, <i>ST</i> is a single 
real-
valued variable shared by all threads that is never reset and whose rate is 1 in all states.&#160; <i>ST</i> 
is 
called the global real time.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Two 
periodic threads are said to be synchronized if, whenever they are both active in the current 
system mode of operation, they are logically dispatched simultaneously at every global real time 
<i>ST</i> that is a nonnegative integral multiple of the least common multiple of their periods, i.e., 
their 
hyperperiod.&#160; Two threads are logically dispatched simultaneously if the order in which all 
exchanges of control and data at that dispatch event are identical to the order that would occur if 
those dispatches were exactly dispatched simultaneously in true and perfect real time.&#160; If all 
periodic threads contained in an application system are synchronized, then that application 
system is said to be synchronized.&#160; In this version of the standard, system instances are 
synchronized. By default, all application system instances are synchronized, i.e., all periodic 
threads contained in an application system must be synchronized.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><b>Runtime 
Support</b></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The 
following paragraphs define standard runtime services that are to be provided.&#160; The application 
program interface for these services is defined in the applicable source language annex of this 
standard. They are callable from within the source text.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A </span></font><font 
face="Courier New"><span>Raise_Event</span></font><font face="Helvetica"><span> runtime service shall 
be provided that allows a thread to explicitly raise an event 
if the executing thread has the named port specified as out event port or an out event data port.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A </span></font><font 
face="Courier New"><span>Raise_Error</span></font><font face="Helvetica"><span> runtime service shall 
be provided that allows a thread to explicitly raise a thread 
recoverable or thread unrecoverable error as specified by a runtime parameter.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
a local subprogram calls </span></font><font face="Courier New"><span>Raise_Event</span></font><font 
face="Helvetica"><span>, the event is routed according to the event connection 
declaration associated with the subprogram call&#146;s event port.&#160; If a server subprogram calls 
</span></font><font face="Courier New"><span>Raise_Event</span></font><font face="Helvetica"><span>, 
the event is transferred to the subprogram call and routed according to the event 
connection declaration associated with the subprogram call&#146;s event port.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Subprograms 
have event ports but do not have an error port. If a </span></font><font face="Courier New"><span>Raise_Error</span></font><font 
face="Helvetica"><span> is called, it is 
passed to the error port of the enclosing thread.&#160; If a </span></font><font face="Courier New"><span>Raise_Error</span></font><font 
face="Helvetica"><span> is called by a server 
subprogram, the error is passed to the error port of the thread executing the server subprogram.</span></font><span></span></div>
<div align="center" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span><i>Processing 
Requirements and Permissions</i></span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Multiple 
models of implementation are permitted for the dispatching of threads.&#160; One such model 
is that a runtime executive contains the logic reflected in Figure 5 and calls on the different 
entrypoints associated with a thread.&#160; This model naturally supports source text in a higher level 
domain language.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>An 
alternative model is that the code in the source text includes a code pattern that reflects the 
logic of Figure 5 through explicitly programmed calls to the standard </span></font><font face="Courier New"><span>Await_Dispatch</span></font><font 
face="Helvetica"><span> runtime 
service, including a repeated call (while loop) to reflect repeated dispatch of the compute 
entrypoint code sequence.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Multiple 
models of implementation are permitted for the implementation of thread entrypoints.&#160; 
One such model is that each entrypoint is a possibly separate function in the source text that is 
called by the runtime executive.&#160; In this case, the logic to determine the context of an error 
is 
included in the runtime system.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
second model of implementation is that a single function in the source text is called for all 
entrypoints.&#160; This function then invokes an implementer-provided </span></font><font face="Courier New"><span>Dispatch_Status</span></font><font 
face="Helvetica"><span> runtime 
service call to identify the context of the call and to branch to the appropriate code sequence.&#160; 
This alternative is typically used in conjunction with the source text implementation of the 
dispatch loop for the compute entrypoint execution.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing a system is permitted to choose how executing threads will be 
scheduled.&#160; A method of implementation is required to verify to the required level of assurance 
that the resulting schedule satisfies the period and deadline properties.&#160; That is, a method of 
implementing a system should schedule all threads so that the specified timing constraints are 
always satisfied.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>The 
use of the term &#147;preempt&#148; to name a scheduling state transition in Figure 6 does not imply 
that preemptive scheduling disciplines must be used; non-preemptive disciplines are permitted.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>Execution 
times associated with transitions between thread scheduling states, for example 
context swap times (specified as properties of the hosting processor), are not billed to the 
thread&#146;s actual execution time, i.e., are not reflected in the </span></font><font face="Courier New"><span>Compute_Time</span></font><font 
face="Helvetica"><span> property value.&#160; 
However, these times must be included in a detailed schedulability model for a system.&#160; These 
times must either be apportioned to individual threads, or to anonymous threads that are 
introduced into the schedulability model to account for these overheads.&#160; A method of processing 
specifications is permitted to use larger compute time values than those specified for a thread in 
order to account for these overheads when constructing or analyzing a system.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing a system must support the periodic dispatch protocol.&#160; A method of 
implementation may support only a subset of the other standard dispatch protocols.&#160; A method of 
implementation may support additional dispatch protocols not defined in this standard.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing the </span></font><font face="Courier New"><span>Raise_Event</span></font><font 
face="Helvetica"><span> service call may provide an optional parameter that 
permits the assignment of an </span></font><font face="Courier New"><span>Urgency</span></font><font 
face="Helvetica"><span> value to the event.&#160; Such an </span></font><font face="Courier New"><span>Urgency</span></font><font 
face="Helvetica"><span> value provides 
control over the implementation-dependent ordering of events or event data.&#160; This is the case for 
logically simultaneous events or event data arriving at the same event or event data port, and for 
logically simultaneous events resulting in different mode transitions.&#160; This capability also allows 
priority-based </span></font><font face="Courier New"><span>Queue_Processing_Protocols</span></font><font 
face="Helvetica"><span> to be supported for event and event data ports.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing the </span></font><font face="Courier New"><span>Raise_Event</span></font><font 
face="Helvetica"><span> service call may provide a status return value 
indicating whether the raised event or event data connected to an event or event data port is 
ignored on delivery to an event or event data port, or whether a raised event that triggers a mode 
transition is ignored.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementation may choose to generate the </span></font><font face="Courier New"><span>Get_Resource</span></font><font 
face="Helvetica"><span> and 
</span></font><font face="Courier New"><span>Release_Resource</span></font><font face="Helvetica"><span> 
calls in support of critical regions for shared data access as part of the 
AADL runtime system generation, or it may choose to require the application programmer to 
place those calls into the application code. </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing a system may perform loading and initialization activities prior to the 
start of system operation.&#160; For example, binary images of processes and initial data values may 
be loaded by permanently storing them in programmable memory prior to system operation.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing a system must specify the set of errors that may be detected at 
runtime.&#160; This set must be exhaustively and exclusively divided into those errors that are thread 
recoverable or thread unrecoverable, and those that are exceptions to be handled by language 
constructs defined in the applicable programming language standard.&#160; The set of errors classified 
as source language exceptions may be a subset of the exceptions defined in the applicable 
source language standard.&#160; That is, a method of implementation may dictate that a language-
defined exceptional condition should not cause a runtime source language exception but instead 
immediately result in an error.&#160; For each error that is treated as a source language exception, 
if 
the source text associated with that thread fails to properly catch and handle that exception, a 
method of implementation must specify whether such unhandled exceptions are thread 
recoverable or thread unrecoverable errors.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
consequence of the above permissions is that a method of implementing a system may 
classify all errors as thread unrecoverable, and may not provide an executing recovery scheduling 
state and transitions to and from it.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing a system may enforce, at runtime, a minimum time interval between 
dispatches of sporadic threads.&#160; A method of implementing a system may enforce, at runtime, 
the minimum and maximum specified execution times.&#160; A method of implementing a system may 
detect at runtime timing violations.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>A 
method of implementing a system may support handling of errors that are detected while a 
thread is in the suspended, ready, or blocked state.&#160; For example, a method of implementation 
may detect event arrivals for a sporadic thread that violate the specified period.&#160; Such errors 
are to 
be kept pending until the thread enters the executing state, at which instant the errors are raised 
for that thread and cause it to immediately enter the recover state.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
alternative thread scheduling semantics are used, a thread unrecoverable error that occurs in 
the perform thread initialization state may result in a transition to the perform thread recovery 
state and thence to the </span></font><font face="Helvetica" color="#010101"><span>suspended</span></font><font 
face="Helvetica"><span> awaiting mode state, rather than to the </span></font><font face="Helvetica" color="#010101"><span>thread</span></font><font 
face="Helvetica"><span> halted state.&#160; 
The deadline for this sequence is the sum of the initialization deadline and the recovery deadline.&#160; </span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If&#160; 
alternative thread scheduling semantics are used, a method of implementation may 
prematurely terminate threads when a system mode change occurs that does not contain them, 
instead of entering suspended awaiting mode.&#160; Any </span></font><font face="Helvetica" color="#010101"><span>blocking 
resources</span></font><font face="Helvetica"><span> </span></font><font face="Helvetica" color="#010101"><span>acquired 
by the thread</span></font><font face="Helvetica"><span> 
must be </span></font><font face="Helvetica" color="#010101"><span>released.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>If 
alternative thread scheduling semantics are used, the load deadline and initialize deadline may 
be greater than the period for a thread.&#160; In this case, dispatches of periodic threads shall not 
occur at any dispatch point prior to the initialization deadline for that periodic thread.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>This 
standard does not specify which thread or threads perform virtual address space loading.&#160; 
This may be a thread in the runtime system or one of the application threads.</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica"><span>NOTES:</span></font><span></span></div>
<div align="left" style="margin-left=2mm; margin-right=0mm; text-indent=0mm"><font face="Helvetica" size="1"><span 
style="font-size:9pt">The deadline of a calling thread will impose an end-to-end deadline on all activities 
performed by or on 
behalf of that thread, including the time required to perform any server subprogram calls made by that 
thread. The deadline property of a server subprogram may be useful for scheduling methods that 
assign intermediate deadlines in the course of producing an overall end-to-end system schedule.</span></font><span></span></div></div>




  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>
<!--END PAGE BODY ITEM-->


<!-- BEGIN TOP BUTTON -->
<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <div class="body">
      <div class="topCommand">
        <span class="commands">
      <span class="command">
            <img src="Res/images/top_button.gif" alt="">
          <a href="javascript:scroll(0,0)">
             <span class="label">Top</span>
              </a>
    </span>
       </span>
      </div>
    </div>
  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>
<!-- END TOP BUTTON -->

</table>

<!-- BEGIN SIDE NAVIGATION WRAPPER-->
    </td>
  </tr>
</table>
<!-- END SIDE NAVIGATION WRAPPER-->

<!-- END PAGE BODY-->


</body>
</html>

