<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Architecture Analysis &amp; Design Language Summary</title>
   <link href="Res/styles/shared.css" rel="stylesheet" type="text/css">
   <link href="Res/styles/DynamicOutline.css" rel="stylesheet" type="text/css">
</head>
<body id="page" >

<!-- BEGIN PAGE BODY-->


<table id="pageBody">
 <col class="main">
 <col class="right">

<!-- BEGIN BREADCRUMBS-->
<tr id="breadcrumbsAndPageNavigation">
  <td class="breadcrumbs" valign="top">
<!-- BEGIN NAVIGATION BREADCRUMBS ITEM-->
<span class="breadcrumb">
   <a href="index.html">Home</a> 
   <span class="separator">&gt;</span>
</span>
<!-- END NAVIGATION BREADCRUMBS ITEM-->
<!-- BEGIN NAVIGATION BREADCRUMBS HERE-->
<span class="breadcrumb">
   3. Architecture Analysis &amp; Design Language Summary
</span>
<!-- END NAVIGATION BREADCRUMBS HERE-->

  </td>
  <td class="pageNavigation" valign="top">
<!-- START PAGE NAVIGATION NEXT IN SEQUENCE IMAGES -->
<span class="commands">
    <span class="command">
        <img src="Res/images/previous_button.gif" alt=""> <a href="References.html">
        <span class="label">Previous</span></a>
    </span>
&nbsp;&nbsp;
    <span class="command">
        <a href="Components,Packages,andAnnexes.html">
        <span class="label">Next</span></a> <img src="Res/images/next_button.gif" alt="">
    </span>
</span>
<!-- END PAGE NAVIGATION NEXT IN SEQUENCE IMAGES  -->

  </td>
  <td class="right" valign="top">
  </td>
</tr>
<!-- END BREADCRUMBS-->

<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <div class="body">
      <div class="topicDivider">
      </div>
    </div>
  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>

<!--BEGIN PAGE BODY ITEM-->
<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <table>
      <tr class="topicHeader">
        <td class="topicImageColumn">

        </td>
        <td class="topicLineColumn">
          <a name="Topic19"></a>
          <span class=outlineNumberFirst>3. </span><span class=topicLineFirst>Architecture Analysis &amp; Design Language Summary</span>
          <span class="topicIcons">

          </span>
        </td>
      </tr>
    </table>

<!-- phf:Comand: Expand("BoxPartMap.mmbas") -->
     <div class="topicTextNotes"><div align="left"><font face="Helvetica"><span>This section provides an informative overview of AADL 
concepts, structure, and use.&#160; In this section 
the first appearance of a term that has a specific meaning in this standard will be italicized.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>An <i>AADL specification</i> consists of <i>AADL global 
declarations </i>and<i> AADL declarations</i>.&#160; The AADL 
global declarations are comprised of <i>package specifications</i> and <i>property set declarations</i>.&#160; 
AADL 
declarations include <i>component type</i>s, <i>component implementations</i>, <i>port group types</i>, 
and <i>annex 
libraries</i>.&#160; AADL component type and implementation declarations model kinds of physical system 
components, such as a kind of hardware processor or a software program.&#160; This standard defines 
the following categories of components: <i>data</i>, <i>subprogram</i>, <i>thread</i>,<i> thread group</i>, <i>process</i>, <i>memory</i>, 
<i>bus</i>, <i>processor</i>, <i>device</i>, and <i>system</i>.&#160; They form the core of the AADL 
modeling vocabulary.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component type specifies a functional interface in 
terms of <i>features</i>,<i> flow specifications</i>,<i> </i>and<i> 
properties</i>.&#160; It represents a specification of the component against which other components 
can 
operate. Implementations of the component are required to satisfy this specification.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation specifies an internal structure 
in terms of <i>subcomponents</i>, 
<i>connections</i> between the features of those subcomponents, <i>flows</i> across a sequence of 
subcomponents,<i> modes </i>to represent operational states<i>,</i> and properties.&#160; Unlike many 
other 
languages, the AADL allows multiple implementations to be declared with the same functional 
interface. </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Packages provide a library-like structure for organizing 
component type and component 
implementation declarations into separate namespaces and combining them into a system 
specification.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Components may be hierarchically decomposed into collections 
or assemblies of interacting 
subcomponents.&#160; A subcomponent declares a component that is contained in another component, 
naming a component type and component implementation to specify an interface and 
implementation for the subcomponent.&#160; Thus, component types and implementations act as 
<i>component classifiers</i>. The hierarchy of a system instance is based upon the set of 
subcomponents of the top-level system implementation. It is completed by iteratively traversing the 
tree of the component classifiers specified starting at the top-level system implementation 
subcomponents.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A feature describes a functional interface of a component 
through which control and data may be 
exchanged with other components.&#160; Features can be <i>ports</i> to support directional flow of control 
and 
data, <i>subprograms</i> to represent synchronous procedure calls, and <i>requires</i> and <i>provides</i> <i>access</i> 
to 
subcomponents to represent shared access to data and bus components.&#160; Required 
subcomponent access specifies the need for a component to access components declared outside 
the component.&#160; Provided subcomponent access specifies that a subcomponent contained in a 
component is made externally accessible.&#160; Ports in an AADL specification may map to a variable 
in a piece of source code, i.e., a storage location in a physical memory.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Subcomponents allow systems to be specified as a static 
and tree-like containment hierarchy. The 
AADL also allows components to reference subcomponents that are not contained exclusively in 
the component.&#160; This allows a component to be accessed or used in more than one component. In 
the AADL, data and bus components can have shared access.&#160; For example, static data items 
contained in a source text software package and represented in AADL as data components may 
be used by threads in different processes (whose protected address spaces may otherwise be 
distinct).&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Syntactically the terms component type declaration, component 
implementation declaration, and 
subcomponent declaration refer to specific grammar rules for each component category. 
Semantically, a component may have subcomponents while it itself is a subcomponent of some 
other component.&#160; The terms component and subcomponent must be interpreted semantically as a 
relationship between two components that are identified by context.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Components, features, modes, connections, flows, and 
subprogram calls can have properties. A 
property has a name, a type and a value.&#160; Properties are used to represent attributes and other 
characteristics, such as the period and deadline of threads.&#160; When properties are associated with 
declarations of component types, component implementations, features, subcomponents, 
connections, flows, and modes, they apply to all respective instances within a system instance. 
The AADL also supports the specification of instance specific values of any unit in the containment 
hierarchy of a system instance.&#160; AADL tools may record these values for use in the analysis of 
the 
system instance or for use in the construction of new system instances.&#160; Properties can have 
mode-specific and binding-specific values.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>This standard defines a set of predeclared properties 
and property types.&#160; Additional properties and 
property types to support new forms of system analysis can be introduced through property sets. 
Property values can be associated with component types, component implementations, 
subcomponents, features, connections, flows, modes, and subprogram calls.&#160; For example, a 
property is used to identify the source code files associated with a software component. Another 
example of the use of properties is specifying hardware memory, i.e., the number of addressable 
storage units and their size.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL component type and component implementation declarations 
can be organized into 
packages. Each package provides a separate namespace for component type and implementation 
declarations.&#160; A component classifier in a package is referenced externally&#160; be qualifiing 
its name 
with the package name.&#160; Packages can be nested and referenced externally utilizing qualified 
names.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Features and flow specifications of component types may 
be partially specified.&#160; Similarly, 
subcomponents, connections, flows, and modes of component implementations may have 
incomplete specifications.&#160; These specifications may be later refined in component type and 
component implementation extensions with the completion of classifier references and property 
associations.&#160; Component type extensions&#160; can also introduce additional features, flow 
specifications, and properties.&#160; Such extensions can add new subcomponents, connections, flows, 
modes, and properties to component implementations.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A system modeled in AADL consists of application software 
mapped to an execution platform. 
Data, subprograms, threads, thread groups, and processes collectively represent application 
software. They are called <i>software</i> components.&#160; Processor, memory, bus, and device collectively 
represent the execution platform. They are called <i>execution platform</i> components.&#160; Execution 
platform components support the execution of threads, the storage of data and code, and the 
communication between threads.&#160; Systems are called <i>compositional</i> components. They permit 
software and execution platform components to be organized into hierarchical structures with well- 
defined interfaces. Operating systems may be represented through properties of the execution 
platform or, requiring significantly more detail, modeled as software components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Software components model<i> source text, virtual address 
spaces,</i> and <i>units of concurrent 
execution.</i>&#160; Source text can be written in a programming language such as Ada 95, C, or Java, 
or 
domain-specific modeling languages such as Simulink, SDL, ESTEREL, LUSTRE, and UML, for 
which executable code may be generated.&#160; The source text modeled by a software component 
may represent a partial application program or model (e.g., they form one or more independent 
compilation units as defined by the applicable programming language standard).&#160; Rules and 
permissions governing the mapping between AADL specification and source text depend on the 
applicable programming or modeling language standard.&#160; Predeclared component properties 
identify the source text container and the mapping of AADL concepts to source text declarations 
and statements.&#160; These properties also specify memory and execution times requirements and 
other known characteristics of the component.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL data components represent static data in source 
text.&#160; This data can be shared by threads 
and processes; they do so by the indicating that they require access to the external data 
component.&#160; Concurrent access to data is managed by the appropriate concurrency control 
protocol as specified by a property.&#160; Realizations of such protocols are documented in an 
appropriate implementation Annex in this standard.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Data types in the source text are modeled by the declarations: 
data component type and data 
component implementation.&#160; Thus, a data component classifier represents the data type of data 
components, ports, and subprogram parameters.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The subprogram component models source text that is executed 
sequentially.&#160; Subprograms are 
callable from within threads and subprograms.&#160; Subprograms may require access to data 
components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL thread components model units of concurrent execution, 
i.e., concurrent runtime threads of 
control or threads of execution through source text (or more exactly, through binary images 
produced from the compilation, linking and loading of source text).&#160; A scheduler manages the 
execution of a thread.&#160; The dynamic semantics for a thread are defined in this standard using 
hybrid automata.&#160; The threads can be in states such as suspended, ready, and running.&#160; State 
transitions occur as a result of dispatch requests, faults, and runtime service calls.&#160; They can 
also 
occur if time constraints are exceeded.&#160; Error detection and recovery semantics are specified. 
Dispatch semantics are given for standard dispatch protocols such as periodic, sporadic, and 
aperiodic threads as well as background threads. Additional dispatch protocols may be defined. 
Threads can contain subprogram and data components, and provide or require access to data 
components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL thread groups support structural grouping of threads 
within a process.&#160; A thread group may 
contain data, thread, and thread group subcomponents.&#160; A thread group may require and provide 
access to data components.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL process components model space partitions in terms 
of virtual address spaces containing 
source text that forms complete programs as defined in the applicable programming language 
standard.&#160; Access protection of the virtual address space is enforced at runtime if specified by 
the 
property </span></font><font face="Courier New"><span>Runtime_Protection</span></font><font face="Helvetica"><span>. 
The binary image produced by compiling and linking this source 
text must execute properly when loaded into a unique virtual address space.&#160; As processes do not 
represent units of concurrent execution, they must contain at least one thread.&#160; Processes can 
contain thread groups, threads, and data components, and can access or share data components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Execution platform components represent hardware and 
software that is capable of scheduling 
threads, of enforcing specified address space protection at runtime, of storing source text code and 
data, of interfacing with an external environment, and of performing communication for application 
system connections.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL processor components are an abstraction of hardware 
and software that is responsible for 
scheduling and executing threads. In other words, a processor may include functionality provided 
by operating systems.&#160; Alternatively, operating systems can be modeled like application 
components.&#160; Processors can contain memory and require access to buses.&#160; Processors can 
support different scheduling protocols. Threads are bound to processors for scheduling and 
execution.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL memory components model randomly accessible physical 
storage such as RAM or ROM. 
Memories have properties such as the number and size of addressable storage locations.&#160; Binary 
images of source text are bound to memory. Memory can contain nested memory components. 
Memory components require access to buses.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL bus components model communication channels that 
can exchange control and data 
between processors, memories, and devices.&#160; A bus is typically hardware that supports specific 
communication protocols, possibly implemented through software.&#160; Processors, memories, and 
devices communicate by accessing a shared bus.&#160; Buses can be directly connected to other 
buses.&#160; Logical connections between threads that are bound to different processors transmit their 
information across buses that provide the physical connection between the processors. Buses can 
require access to other buses.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL device components model physical devices that interface 
with an external environment, e.g. 
sensors and actuators providing an interface between a physical plant and a control system or a 
GPS system. They may exhibit complex behaviors.&#160; Devices are logically connected to application 
software components and physically connected to processors. They cannot store nor execute 
application software source text themselves, but may include driver software executed on a 
connected processor.&#160; A device requires access to buses.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL systems model hierarchical compositions of software 
and execution platform components. A 
system may contain data, thread, thread group, process, memory, processor, bus, device, and 
system subcomponents.&#160; A system may require and provide access to data and bus components.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL modes represent the operational states of software, 
execution platform, and compositional 
components in the modeled physical system.&#160; A component can have mode- specific property 
values. A component can also have mode- specific configurations of different subsets of 
subcomponents and connections.&#160; In other words, a mode change can change the set of active 
components and connections. Mode transitions model dynamic operational behavior that 
represents switching between configurations and changes in component-internal characteristics, 
such as conditional execution source text sequences or operational states of a device, that are 
reflected in property values. Other examples of mode-specific property values include the period or 
the worst-case execution time of a thread.&#160; A change in operating mode can have the effect of 
activating and deactivating threads for execution and changing the pattern of connections between 
threads.&#160; A mode subclause in a component implementation specifies the mode states and mode 
change behavior in terms of transitions; it specifies the events as transition triggers. Subcomponent 
and connection declarations as well as property associations declare their applicability 
(participation) in specific modes.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>This standard defines several categories of features: 
data port, event port, event data port, port 
group,&#160; data subprogram, server subprogram, and subprogram parameter, and provided and 
required subcomponent access.&#160; Data ports represent connection points for transfer of state data 
such as sensor data.&#160; Event ports represent connection points for transfer of control through raised 
events that can trigger thread dispatch or mode transition. Event data ports represent connection 
points for transfer of events with data, i.e., messages that may be queued.&#160; Ports groups support 
grouping of ports, such that they can be connected to other components through a single 
connection.&#160; Data subprograms represent entrypoints to code sequences in source text that are 
associated with a data type.&#160; Server subprograms represent connection points for synchronous 
call/returns between threads; in some instances the call/return may be remote.&#160; Subprogram 
parameters represent in and out parameters of a subprogram. Data component access represents 
provided and required access to shared data.&#160; Bus component access represents provided and 
required access to buses for processors, memory, and devices. </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL connections specify patterns of control and data 
flow between individual components at 
runtime.&#160; A semantic connection can be made between two threads, between a thread and a 
device or processor, or between a thread, device, or processor and a mode transition. A mode 
transition is represented by a set of one or more connection declarations that follow the component 
hierarchy from the ultimate connection source to the ultimate connection destination.&#160; For 
example, in Figure 1 there is a connection declaration from a thread out port in Thread1 to a 
containing process out port in Process3.&#160; This connection is continued with a connection 
declaration within System1 from Process3&#146;s out port to Process4&#146;s in port.&#160; The connection 
declaration continues within Process4 to the thread in port contained in Thread2. Collectively, this 
sequence of connections defines a single semantic connection between Thread1 and Thread2. 
Threads, processes, systems, and ports are shown in graphical AADL notation.&#160; For a full 
description of the graphical AADL notation see Annex A.</span></font><span></span></div>
<div align="center"><img src="NotesImages/Topic19NotesImage4.jpg" align="bottom" width="451" height="169" border="0" alt="graphic" /></div>
<div align="center"><font face="Helvetica"><span><b>Figure 1 Example Semantic Connections</b></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Flow specifications describe externally observable flow 
of information in terms of application logic 
through a component. Such logical flows may be realized through ports and connections of different 
data types and a combination of data, event, and event data ports.&#160; Flow specifications represent 
<i>flow sources</i>, i.e., flows originating from within a component, <i>flow sinks</i>, i.e., flows 
ending within a 
component, and <i>flow paths</i>, i.e., flows through a component from its incoming ports to its outgoing 
ports. </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Flows describe actual flow sequences through components 
and sets of components across one or 
more connections.&#160; They are declared in component implementations.&#160; Flow sequences take two 
forms: <i>flow implementation</i> and <i>end-to- end flow</i>.&#160; A flow implementation describes 
how a flow 
specification of a component is realized in its component implementation.&#160; An end-to-end flow 
specifies a flow that starts within one subcomponent and ends within another subcomponent.&#160; Flow 
specifications, flow implementations, and end-to-end flows can have expected and actual values for 
flow related properties, e.g., latency or rounding error accumulation.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A physical system is modeled by instantiating a system 
implementation that consists of 
subcomponents representing the application software and execution platform components used to 
execute the application, including devices that interface with the external environment.&#160; A system 
instance represents the complete component hierarchy as specified by the system classifier&#146;s 
subcomponents and the subcomponents of their component classifiers down to the lowest level 
defined in the architecture specification.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>An AADL specification may be used in a variety of ways 
by a variety of tools during a broad range 
of life- cycle activities, e.g. for documentation during preliminary specification, for schedulability 
or 
reliability analysis during design studies and during verification, for generation of system integration 
code during implementation.&#160; Note that application software components must be bound to 
execution platform components - ultimately threads to processors and binary images to memory in 
order for the system to be analyzable for runtime properties and the physical system to be 
constructed from the AADL specification.&#160; Many uses of an AADL specification need not be fully 
automated, e.g. some implementation steps may be performed by hand.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The AADL core language is extensible through property 
sets, <i>annex subclauses </i>and <i>annex 
libraries</i>.&#160; Annex subclauses consist of annex-specific sublanguages whose constructs can be 
added to component types and component implementations. Annex libraries are declarations of 
reusable annex-specific sublanguage elements that can be referenced in annex subclauses. </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>This section provides an informative overview of AADL 
concepts, structure, and use.&#160; In this section 
the first appearance of a term that has a specific meaning in this standard will be italicized.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>An <i>AADL specification</i> consists of <i>AADL global 
declarations </i>and<i> AADL declarations</i>.&#160; The AADL 
global declarations are comprised of <i>package specifications</i> and <i>property set declarations</i>.&#160; 
AADL 
declarations include <i>component type</i>s, <i>component implementations</i>, <i>port group types</i>, 
and <i>annex 
libraries</i>.&#160; AADL component type and implementation declarations model kinds of physical system 
components, such as a kind of hardware processor or a software program.&#160; This standard defines 
the following categories of components: <i>data</i>, <i>subprogram</i>, <i>thread</i>,<i> thread group</i>, <i>process</i>, <i>memory</i>, 
<i>bus</i>, <i>processor</i>, <i>device</i>, and <i>system</i>.&#160; They form the core of the AADL 
modeling vocabulary.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component type specifies a functional interface in 
terms of <i>features</i>,<i> flow specifications</i>,<i> </i>and<i> 
properties</i>.&#160; It represents a specification of the component against which other components 
can 
operate. Implementations of the component are required to satisfy this specification.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation specifies an internal structure 
in terms of <i>subcomponents</i>, 
<i>connections</i> between the features of those subcomponents, <i>flows</i> across a sequence of 
subcomponents,<i> modes </i>to represent operational states<i>,</i> and properties.&#160; Unlike many 
other 
languages, the AADL allows multiple implementations to be declared with the same functional 
interface. </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Packages provide a library-like structure for organizing 
component type and component 
implementation declarations into separate namespaces and combining them into a system 
specification.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Components may be hierarchically decomposed into collections 
or assemblies of interacting 
subcomponents.&#160; A subcomponent declares a component that is contained in another component, 
naming a component type and component implementation to specify an interface and 
implementation for the subcomponent.&#160; Thus, component types and implementations act as 
<i>component classifiers</i>. </span></font><font size="1"><span style="font-size:9pt">The hierarchy 
of a system instance is based upon the set of subcomponents of 
the top-level system implementation. It is completed by iteratively traversing the tree of the component 
classifiers specified starting at the top-level system implementation subcomponents.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A feature describes a functional interface of a component 
through which control and data may be 
exchanged with other components.&#160; Features can be <i>ports</i> to support directional flow of control 
and 
data, <i>subprograms</i> to represent synchronous procedure calls, and <i>requires</i> and <i>provides</i> <i>access</i> 
to 
subcomponents to represent shared access to data and bus components.&#160; Required 
subcomponent access specifies the need for a component to access components declared outside 
the component.&#160; Provided subcomponent access specifies that a subcomponent contained in a 
component is made externally accessible.&#160; Ports in an AADL specification may map to a variable 
in a piece of source code, i.e., a storage location in a physical memory.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Subcomponents allow systems to be specified as a static 
and tree-like containment hierarchy. The 
AADL also allows components to reference subcomponents that are not contained exclusively in 
the component.&#160; This allows a component to be accessed or used in more than one component. In 
the AADL, data and bus components can have shared access.&#160; For example, static data items 
contained in a source text software package and represented in AADL as data components may 
be used by threads in different processes (whose protected address spaces may otherwise be 
distinct).&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Syntactically the terms component type declaration, component 
implementation declaration, and 
subcomponent declaration refer to specific grammar rules for each component category. 
Semantically, a component may have subcomponents while it itself is a subcomponent of some 
other component.&#160; The terms component and subcomponent must be interpreted semantically as a 
relationship between two components that are identified by context.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Components, features, modes, connections, flows, and 
subprogram calls can have properties. A 
property has a name, a type and a value.&#160; Properties are used to represent attributes and other 
characteristics, such as the period and deadline of threads.&#160; When properties are associated with 
declarations of component types, component implementations, features, subcomponents, 
connections, flows, and modes, they apply to all respective instances within a system instance. 
The AADL also supports the specification of instance specific values of any unit in the containment 
hierarchy of a system instance.&#160; AADL tools may record these values for use in the analysis of 
the 
system instance or for use in the construction of new system instances.&#160; Properties can have 
mode-specific and binding-specific values.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>This standard defines a set of predeclared properties 
and property types.&#160; Additional properties and 
property types to support new forms of system analysis can be introduced through property sets. 
Property values can be associated with component types, component implementations, 
subcomponents, features, connections, flows, modes, and subprogram calls.&#160; For example, a 
property is used to identify the source code files associated with a software component. Another 
example of the use of properties is specifying hardware memory, i.e., the number of addressable 
storage units and their size.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL component type and component implementation declarations 
can be organized into 
packages. Each package provides a separate namespace for component type and implementation 
declarations.&#160; A component classifier in a package is referenced externally&#160; be qualifiing 
its name 
with the package name.&#160; Packages can be nested and referenced externally utilizing qualified 
names.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Features and flow specifications of component types may 
be partially specified.&#160; Similarly, 
subcomponents, connections, flows, and modes of component implementations may have 
incomplete specifications.&#160; These specifications may be later refined in component type and 
component implementation extensions with the completion of classifier references and property 
associations.&#160; Component type extensions&#160; can also introduce additional features, flow 
specifications, and properties.&#160; Such extensions can add new subcomponents, connections, flows, 
modes, and properties to component implementations.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A system modeled in AADL consists of application software 
mapped to an execution platform. 
Data, subprograms, threads, thread groups, and processes collectively represent application 
software. They are called <i>software</i> components.&#160; Processor, memory, bus, and device collectively 
represent the execution platform. They are called <i>execution platform</i> components.&#160; Execution 
platform components support the execution of threads, the storage of data and code, and the 
communication between threads.&#160; Systems are called <i>compositional</i> components. They permit 
software and execution platform components to be organized into hierarchical structures with well- 
defined interfaces. Operating systems may be represented through properties of the execution 
platform or, requiring significantly more detail, modeled as software components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Software components model<i> source text, virtual address 
spaces,</i> and <i>units of concurrent 
execution.</i>&#160; Source text can be written in a programming language such as Ada 95, C, or Java, 
or 
domain-specific modeling languages such as Simulink, SDL, ESTEREL, LUSTRE, and UML, for 
which executable code may be generated.&#160; The source text modeled by a software component 
may represent a partial application program or model (e.g., they form one or more independent 
compilation units as defined by the applicable programming language standard).&#160; Rules and 
permissions governing the mapping between AADL specification and source text depend on the 
applicable programming or modeling language standard.&#160; Predeclared component properties 
identify the source text container and the mapping of AADL concepts to source text declarations 
and statements.&#160; These properties also specify memory and execution times requirements and 
other known characteristics of the component.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL data components represent static data in source 
text.&#160; This data can be shared by threads 
and processes; they do so by the indicating that they require access to the external data 
component.&#160; Concurrent access to data is managed by the appropriate concurrency control 
protocol as specified by a property.&#160; Realizations of such protocols are documented in an 
appropriate implementation Annex in this standard.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Data types in the source text are modeled by the declarations: 
data component type and data 
component implementation.&#160; Thus, a data component classifier represents the data type of data 
components, ports, and subprogram parameters.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The subprogram component models source text that is executed 
sequentially.&#160; Subprograms are 
callable from within threads and subprograms.&#160; Subprograms may require access to data 
components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL thread components model units of concurrent execution, 
i.e., concurrent runtime threads of 
control or threads of execution through source text (or more exactly, through binary images 
produced from the compilation, linking and loading of source text).&#160; A scheduler manages the 
execution of a thread.&#160; The dynamic semantics for a thread are defined in this standard using 
hybrid automata.&#160; The threads can be in states such as suspended, ready, and running.&#160; State 
transitions occur as a result of dispatch requests, faults, and runtime service calls.&#160; They can 
also 
occur if time constraints are exceeded.&#160; Error detection and recovery semantics are specified. 
Dispatch semantics are given for standard dispatch protocols such as periodic, sporadic, and 
aperiodic threads as well as background threads. Additional dispatch protocols may be defined. 
Threads can contain subprogram and data components, and provide or require access to data 
components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL thread groups support structural grouping of threads 
within a process.&#160; A thread group may 
contain data, thread, and thread group subcomponents.&#160; A thread group may require and provide 
access to data components.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL process components model space partitions in terms 
of virtual address spaces containing 
source text that forms complete programs as defined in the applicable programming language 
standard.&#160; Access protection of the virtual address space is enforced at runtime if specified by 
the 
property </span></font><font face="Courier New"><span>Runtime_Protection</span></font><font face="Helvetica"><span>. 
The binary image produced by compiling and linking this source 
text must execute properly when loaded into a unique virtual address space.&#160; As processes do not 
represent units of concurrent execution, they must contain at least one thread.&#160; Processes can 
contain thread groups, threads, and data components, and can access or share data components.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Execution platform components represent hardware and 
software that is capable of scheduling 
threads, of enforcing specified address space protection at runtime, of storing source text code and 
data, of interfacing with an external environment, and of performing communication for application 
system connections.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL processor components are an abstraction of hardware 
and software that is responsible for 
scheduling and executing threads. In other words, a processor may include functionality provided 
by operating systems.&#160; Alternatively, operating systems can be modeled like application 
components.&#160; Processors can contain memory and require access to buses.&#160; Processors can 
support different scheduling protocols. Threads are bound to processors for scheduling and 
execution.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL memory components model randomly accessible physical 
storage such as RAM or ROM. 
Memories have properties such as the number and size of addressable storage locations.&#160; Binary 
images of source text are bound to memory. Memory can contain nested memory components. 
Memory components require access to buses.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL bus components model communication channels that 
can exchange control and data 
between processors, memories, and devices.&#160; A bus is typically hardware that supports specific 
communication protocols, possibly implemented through software.&#160; Processors, memories, and 
devices communicate by accessing a shared bus.&#160; Buses can be directly connected to other 
buses.&#160; Logical connections between threads that are bound to different processors transmit their 
information across buses that provide the physical connection between the processors. Buses can 
require access to other buses.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL device components model physical devices that interface 
with an external environment, e.g. 
sensors and actuators providing an interface between a physical plant and a control system or a 
GPS system. They may exhibit complex behaviors.&#160; Devices are logically connected to application 
software components and physically connected to processors. They cannot store nor execute 
application software source text themselves, but may include driver software executed on a 
connected processor.&#160; A device requires access to buses.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL systems model hierarchical compositions of software 
and execution platform components. A 
system may contain data, thread, thread group, process, memory, processor, bus, device, and 
system subcomponents.&#160; A system may require and provide access to data and bus components.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL modes represent the operational states of software, 
execution platform, and compositional 
components in the modeled physical system.&#160; A component can have mode- specific property 
values. A component can also have mode- specific configurations of different subsets of 
subcomponents and connections.&#160; In other words, a mode change can change the set of active 
components and connections. Mode transitions model dynamic operational behavior that 
represents switching between configurations and changes in component-internal characteristics, 
such as conditional execution source text sequences or operational states of a device, that are 
reflected in property values. Other examples of mode-specific property values include the period or 
the worst-case execution time of a thread.&#160; A change in operating mode can have the effect of 
activating and deactivating threads for execution and changing the pattern of connections between 
threads.&#160; A mode subclause in a component implementation specifies the mode states and mode 
change behavior in terms of transitions; it specifies the events as transition triggers. Subcomponent 
and connection declarations as well as property associations declare their applicability 
(participation) in specific modes.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>This standard defines several categories of features: 
data port, event port, event data port, port 
group,&#160; data subprogram, server subprogram, and subprogram parameter, and provided and 
required subcomponent access.&#160; Data ports represent connection points for transfer of state data 
such as sensor data.&#160; Event ports represent connection points for transfer of control through raised 
events that can trigger thread dispatch or mode transition. Event data ports represent connection 
points for transfer of events with data, i.e., messages that may be queued.&#160; Ports groups support 
grouping of ports, such that they can be connected to other components through a single 
connection.&#160; Data subprograms represent entrypoints to code sequences in source text that are 
associated with a data type.&#160; Server subprograms represent connection points for synchronous 
call/returns between threads; in some instances the call/return may be remote.&#160; Subprogram 
parameters represent in and out parameters of a subprogram. Data component access represents 
provided and required access to shared data.&#160; Bus component access represents provided and 
required access to buses for processors, memory, and devices. </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>AADL connections specify patterns of control and data 
flow between individual components at 
runtime.&#160; A semantic connection can be made between two threads, between a thread and a 
device or processor, or between a thread, device, or processor and a mode transition. A mode 
transition is represented by a set of one or more connection declarations that follow the component 
hierarchy from the ultimate connection source to the ultimate connection destination.&#160; For 
example, in Figure 1 there is a connection declaration from a thread out port in Thread1 to a 
containing process out port in Process3.&#160; This connection is continued with a connection 
declaration within System1 from Process3&#146;s out port to Process4&#146;s in port.&#160; The connection 
declaration continues within Process4 to the thread in port contained in Thread2. Collectively, this 
sequence of connections defines a single semantic connection between Thread1 and Thread2. 
</span></font><font face="Helvetica" color="#010101"><span>Threads, processes, systems, and ports are 
shown in graphical AADL notation.&#160; For a full 
description of the graphical AADL notation see Annex B.</span></font><span></span></div>
<div align="center"><img src="NotesImages/Topic19NotesImage8.jpg" align="bottom" width="451" height="169" border="0" alt="graphic" /></div>
<div align="center"><font face="Helvetica"><span><b>Figure 1 Example Semantic Connections</b></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Flow specifications describe externally observable flow 
of information in terms of application logic 
through a component. Such logical flows may be realized through ports and connections of different 
data types and a combination of data, event, and event data ports.&#160; Flow specifications represent 
<i>flow sources</i>, i.e., flows originating from within a component, <i>flow sinks</i>, i.e., flows 
ending within a 
component, and <i>flow paths</i>, i.e., flows through a component from its incoming ports to its outgoing 
ports. </span></font><span></span></div>
<div align="left"><font size="1"><span style="font-size:9pt">Flows describe actual flow sequences through 
components and sets of components across one or 
more connections.&#160; </span></font><font face="Helvetica"><span>They are declared in component implementations.&#160; 
Flow sequences take two 
forms: <i>flow implementation</i> and <i>end-to- end flow</i>.&#160; A flow implementation describes 
how a flow 
specification of a component is realized in its component implementation.&#160; An end-to-end flow 
specifies a flow that starts within one subcomponent and ends within another subcomponent.&#160; Flow 
specifications, flow implementations, and end-to-end flows can have expected and actual values for 
flow related properties, e.g., latency or rounding error accumulation.</span></font><span></span></div>
<div align="left">A physical system is modeled by instantiating a system implementation that consists 
of 
subcomponents representing the application software and execution platform components used to 
execute the application, including devices that interface with the external environment.  A system 
instance represents the complete component hierarchy as specified by the system classifier’s 
subcomponents and the subcomponents of their component classifiers down to the lowest level 
defined in the architecture specification.  </div>
<div align="left"><font face="Helvetica"><span>An AADL specification may be used in a variety of ways 
by a variety of tools during a broad range 
of life- cycle activities, e.g. for documentation during preliminary specification, for schedulability 
or 
reliability analysis during design studies and during verification, for generation of system integration 
code during implementation.&#160; Note that application software components must be bound to 
execution platform components - ultimately threads to processors and binary images to memory in 
order for the system to be analyzable for runtime properties and the physical system to be 
constructed from the AADL specification.&#160; Many uses of an AADL specification need not be fully 
automated, e.g. some implementation steps may be performed by hand.&#160; </span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The AADL core language is extensible through property 
sets, <i>annex subclauses </i>and <i>annex 
libraries</i>.&#160; Annex subclauses consist of annex-specific sublanguages whose constructs can be 
added to component types and component implementations. Annex libraries are declarations of 
reusable annex-specific sublanguage elements that can be referenced in annex subclauses. </span></font><span></span></div></div>




  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>
<!--END PAGE BODY ITEM-->


<!-- BEGIN TOP BUTTON -->
<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <div class="body">
      <div class="topCommand">
        <span class="commands">
      <span class="command">
            <img src="Res/images/top_button.gif" alt="">
          <a href="javascript:scroll(0,0)">
             <span class="label">Top</span>
              </a>
    </span>
       </span>
      </div>
    </div>
  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>
<!-- END TOP BUTTON -->

</table>

<!-- BEGIN SIDE NAVIGATION WRAPPER-->
    </td>
  </tr>
</table>
<!-- END SIDE NAVIGATION WRAPPER-->

<!-- END PAGE BODY-->


</body>
</html>

