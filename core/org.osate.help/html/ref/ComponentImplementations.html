<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
	"http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Component Implementations</title>
   <link href="Res/styles/shared.css" rel="stylesheet" type="text/css">
   <link href="Res/styles/DynamicOutline.css" rel="stylesheet" type="text/css">
</head>
<body id="page" >

<!-- BEGIN PAGE BODY-->


<table id="pageBody">
 <col class="main">
 <col class="right">

<!-- BEGIN BREADCRUMBS-->
<tr id="breadcrumbsAndPageNavigation">
  <td class="breadcrumbs" valign="top">
<!-- BEGIN NAVIGATION BREADCRUMBS ITEM-->
<span class="breadcrumb">
   <a href="index.html">Home</a> 
   <span class="separator">&gt;</span>
</span>
<!-- END NAVIGATION BREADCRUMBS ITEM-->
<!-- BEGIN NAVIGATION BREADCRUMBS ITEM-->
<span class="breadcrumb">
   <a href="Components,Packages,andAnnexes.html">4. Components, Packages, and Annexes</a> 
   <span class="separator">&gt;</span>
</span>
<!-- END NAVIGATION BREADCRUMBS ITEM-->
<!-- BEGIN NAVIGATION BREADCRUMBS HERE-->
<span class="breadcrumb">
   4.4 Component Implementations
</span>
<!-- END NAVIGATION BREADCRUMBS HERE-->

  </td>
  <td class="pageNavigation" valign="top">
<!-- START PAGE NAVIGATION NEXT IN SEQUENCE IMAGES -->
<span class="commands">
    <span class="command">
        <img src="Res/images/previous_button.gif" alt=""> <a href="ComponentTypes.html">
        <span class="label">Previous</span></a>
    </span>
&nbsp;&nbsp;
    <span class="command">
        <a href="Subcomponents.html">
        <span class="label">Next</span></a> <img src="Res/images/next_button.gif" alt="">
    </span>
</span>
<!-- END PAGE NAVIGATION NEXT IN SEQUENCE IMAGES  -->

  </td>
  <td class="right" valign="top">
  </td>
</tr>
<!-- END BREADCRUMBS-->

<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <div class="body">
      <div class="topicDivider">
      </div>
    </div>
  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>

<!--BEGIN PAGE BODY ITEM-->
<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <table>
      <tr class="topicHeader">
        <td class="topicImageColumn">

        </td>
        <td class="topicLineColumn">
          <a name="Topic24"></a>
          <span class=outlineNumberFirst>4.4 </span><span class=topicLineFirst>Component Implementations</span>
          <span class="topicIcons">

          </span>
        </td>
      </tr>
    </table>

<!-- phf:Comand: Expand("BoxPartMap.mmbas") -->
     <div class="topicTextNotes"><div align="left"><font face="Helvetica"><span>A <i>component implementation</i>contains subcomponents 
and their connections, properties, and 
component modes. Every component implementation is associated with a component type.&#160; A 
component type may have zero or more component implementations declared.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation consists of a collection of 
zero or more subcomponent and 
subcomponent refinements<i>,</i> connection and connection refinements, subprogram call sequences, 
component type feature refinements, flow sequences, and mode declarations; and zero or more 
property associations.&#160; Flow sequences represent implementations of flow specifications in the 
component type, or end-to-end flows to be analyzed.&#160; Modes represent alternative operational 
modes that may manifest themselves as alternate configurations of subcomponents, connections, 
call sequences, flow sequences, and property values.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation can be declared as an extension 
of another component 
implementation.&#160; In that case, the component implementation inherits the declarations of its 
ancestors as well as its component type. A component implementation extension can refine 
inherited declarations, and add subcomponents, connections, subprogram call sequences, flow 
sequences, mode declarations, and property associations.&#160;</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Component implementations build on the component type <i>extension 
hierarchy</i> in two ways.&#160; First, 
a component implementation is a realization of a component type (shown as dashed arrows in 
Figure 3).&#160; As such it inherits features and property associations of its component type and any 
component type ancestor.&#160; Second, a component implementation declared as extension inherits 
subcomponents, connections, subprogram call sequences, flow sequences, modes, property 
associations, and annex subclauses from the component implementation being extended (shown 
as solid arrows in Figure 3).&#160; A component implementation can extend a component 
implementation that in turn extends another component implementation, e.g., in Figure 3 
GPS.Handheld extends GPS.Basic and is extended by GPS_Secure.Handheld.&#160; Component 
implementations higher in the extension hierarchy are called ancestors and those lower in the 
hierarchy are called descendents.&#160; A component implementation can extend another component 
implementation of its own component type, e.g., GPS.Handheld extends GPS.Basic, or it can 
extend the component implementation of one of its ancestor component types, e.g., 
GPS_Secure.Handheld extends GPS.Handheld, which is an implementation of the ancestor 
component type GPS.&#160; The component type and implementation extension hierarchy is illustrated 
in Figure 3.&#160;</span></font><span></span></div>
<div align="center"><img src="NotesImages/Topic24NotesImage3.jpg" align="bottom" width="559" height="158" border="0" alt="graphic" /></div>
<div align="center"><font face="Helvetica"><span><b>Figure 3 Extension Hierarchy of Component Types 
and Implementations</b></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation may also be extended using 
an annex_subclause to specify 
additional characteristics of the type that are not defined in the core of the AADL (see Section 4.6).</span></font><span></span></div>
<div align="center"><font face="Helvetica"><span><i>Syntax</i></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>component_implementation ::=</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; component_category <b>implementation</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b><i>defining_</i>component_implementation_name</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>refines type</b> 
( { feature_refinement }<sup>+&#160;&#160;</sup> | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>subcomponents</b> 
( { subcomponent }<sup>+&#160;</sup> | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>calls</b> ( { subprogram_call_sequence 
}<sup>+&#160;</sup> | none_statement ) ]&#160;&#160;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>connections</b> ( 
{ connection }<sup>+</sup> | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>flows</b> ( { flow_implementation 
|</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
end_to_end_flow_spec }<sup>+</sup> | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>modes</b> ( { mode 
}<sup>+</sup> { mode_transition }<sup>*</sup>| none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>properties</b> ( 
{ property_association | 
contained_property_association&#160; }<sup>+</sup></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
| none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; { annex_subclause }<sup>*</sup></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160; end</b> <i>defining_</i>component_implementation_name <b>;</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>component_implementation_name ::=</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;<i>component_type</i>_identifier 
. <i>component_implementation</i>_identifier</span></font><span></span></div>
<br/>
<font face="Courier New" color="#010101"><span>component_implementation_extension ::=</span></font><span>
<div align="left"></span><font face="Courier New" color="#010101"><span>&#160;&#160; component_category <b>implementation</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b><i>defining_</i>component_implementation_name</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160; extends</b> unique_component_implementation_name</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>refines type</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
( { feature_refinement }<sup>+&#160;</sup> | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>subcomponents</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;&#160;&#160;&#160;&#160;&#160;</b> 
( { subcomponent | subcomponent_refinement }<sup>+&#160;</sup> | none_statement 
) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>calls</b> ( { subprogram_call_sequence 
}<sup>+&#160;</sup> | none_statement ) ]&#160;&#160;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>connections</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
( { connection | connection_refinement }<sup>+&#160;</sup> | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>flows</b> ( { flow_implementation&#160; 
| flow_implementation_refinement |</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
end_to_end_flow_spec | end_to_end_flow_spec_refinement }<sup>+</sup></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;| none_statement 
) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>modes</b> ( { mode 
| mode_refinement | mode_transition }<sup>+</sup> | 
none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; [ <b>properties</b> ( 
{ property_association }<sup>+</sup>&#160; | none_statement ) ]</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; { annex_subclause }<sup>*</sup></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160; end&#160;&#160;</b> <i>defining_</i>component_implementation_name 
;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>unique_component_implementation_name 
::=</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160; [package_name <b>::</b> 
] component_implementation_name</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>NOTES:</span></font><span></span></div>
<div align="left"><font face="Helvetica" size="1"><span style="font-size:9pt">The above grammar rules 
characterize the common syntax for all component categories. The sections 
defining each of the component categories will specify further restrictions on the syntax.</span></font><span></span></div>
<div align="left"><font face="Helvetica" size="1"><span style="font-size:9pt">The <b>refines type</b>, <b>subcomponents</b>, <b>connections</b>, <b>calls</b>, <b>flows</b>, <b>modes</b>, 
and <b>properties</b>subclauses of the 
component implementation are optional or if used and empty, require an explicit empty declaration.&#160; 
The 
latter is provided to accommodate AADL modeling guidelines that require explicit documentation of empty 
subclauses. An empty subclause declaration consists of the reserved word of the subclause and a none 
statement&#160; ( <b>none ;</b> ).</span></font><span></span></div>
<div align="left"><font face="Helvetica" size="1"><span style="font-size:9pt">The annex_subclause of 
the component implementation is optional.</span></font><span></span></div>
<div align="center"><font face="Helvetica"><span><i>Naming Rules</i></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation name consists of a component 
type identifier and a component 
implementation identifier separated by a dot (&#8220;.&#8221;).&#160; The first identifier of the defining 
component 
implementation name must name a component type that is declared in the same package or 
anonymous namespace as the component implementation.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The defining name of the component implementation must 
be unique within the anonymous 
namespace or within the package namespace of the package within which it is declared.&#160;</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Every component implementation defines a <i>local namespace</i> 
for all defining identifiers of 
subcomponents, subprogram calls, connections, flows, and modes declared within the component 
implementation.&#160; The defining identifier of a subcomponent, subprogram call, connection, flow, 
or 
mode must be unique within this namespace.&#160; For example, a subcomponent and a mode cannot 
have the same defining identifier within the same component implementation.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>This local namespace inherits the interface namespace 
of the associated component type, i.e., 
defining identifiers must be unique within the local namespace and also within the interface 
namespace.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Refinement identifiers of features must exist in the 
interface namespace of the associated 
component type or one of the component type&#8217;s ancestors.&#160; Refinement identifiers of 
subcomponent and connection refinements must exist in the local namespace of an ancestor 
component implementation.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>In a component implementation extension, the component 
type identifier of the component 
implementation being extended, which appears after the reserved word <b>extends</b>, must be the same 
as or an ancestor of the component type of the extension.&#160; The component implementation being 
extended may exist in another package.&#160; In this case the component implementation name is 
qualified with the package name.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>When a component implementation <b>extends</b> another 
component implementation, the local 
namespace of the extension is a superset of the local namespace of the ancestor.&#160; That is, the 
local namespace of a component implementation inherits all the identifiers in the local namespaces 
of its ancestors (including the identifiers of their respective component type interface namespaces).</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Within the scope of the component implementation, subcomponent 
declarations, connections, 
subprogram call sequences, mode transitions, and property associations can refer directly to 
identifiers in the local namespace, i.e., to declared subcomponents, connections, and modes, as 
well as to required subcomponents and features declared in the associated component type.</span></font><span></span></div>
<div align="center"><font face="Helvetica"><span><i>Legality Rules</i></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The pair of identifiers separated by a dot (&#8220;.&#8221;) 
following the reserved word <b>end</b>must be identical to 
the pair of identifiers following the reserved word <b>implementation</b>.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The <b>refines type</b>, <b>subcomponents</b>, <b>connections</b>, <b>calls</b>, <b>flows</b>, <b>modes</b>, 
and <b>properties</b> 
subclauses are optional. If they are present and the set of feature or required subcomponent 
declarations or property associations is empty, <b>none</b> followed by a semi-colon must be present 
in 
that subclause.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The category of the component implementation must match 
the category of the component type for 
which the component implementation is declared.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>If the component implementation extends another component 
implementation, the category of both 
must match.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The <b>refines type</b> subclause must only contain refinement 
declarations of features in the 
component type and those refinements are limited to property associations. Specifically, the 
<b>refines type</b> subclause of a component implementation may not alter the component classifiers 
of 
inherited features.</span></font><span></span></div>
<div align="center"><font face="Helvetica"><span><i>Semantics</i></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation represents the internal structure 
of a component&#160; through 
subcomponent declarations. Interaction between subcomponents is expressed by the connections, 
flows, and subprogram call sequences. Mode declarations represent alternative runtime 
configurations (internal structure) and alternative execution behavior (interaction between 
subcomponents)..&#160; A component implementation also has property values to express its non- 
functional attributes such as safety level or execution time which can also vary by mode.&#160;</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Each component implementation is associated with a component 
type and provides a realization of 
its features (interface).&#160; A component type can have multiple implementations.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The physical system being modeled by component types 
and component implementations may 
contain subcomponents, some of which may contain subcomponents themselves.&#160; The 
subcomponent containment hierarchy reflects the physical system structure.&#160;</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation that is an extension of another 
inherits all subcomponents, 
connections, subprogram call sequences, flow sequences (flow implementations and end-to-end 
flows), modes, property associations, and annex subclauses from its ancestors as well as 
features, property associations, and annex subclauses from its associated component type (and 
that component type&#8217;s ancestors).&#160;</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation extension can also refine 
subcomponents previously declared in 
ancestor component implementations by completing component classifiers, and by associating 
new property values.&#160; A component implementation extension can refine connections, flows, and 
modes of its ancestor component implementations by associating new property values.&#160; A 
component implementation extension can refine features of its associated component type (and 
that component type&#8217;s ancestors) by associating new property values to them.&#160;</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation extension can also add subcomponents, 
connections, subprogram 
call sequences, flow sequences, modes, property associations, and annex subclauses.&#160; This 
extension capability supports evolutionary development and modeling of system families by 
declaring partially complete component implementations that get refined in extensions.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A descendent component implementation is said to contain 
all subcomponents whose identifiers 
appear in its local namespace, i.e., subcomponents declared in the component implementation 
and any of its ancestors.&#160; In other words, an instance of a component implementation extension 
contains instances of declared and inherited subcomponents, features, connections, subprogram 
call sequences, flow sequences, and modes.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>The <b>refines type</b> subclause of a component implementation 
can refine the property associations of 
features of its associated component type and of that component&#8217;s ancestor component types. The 
example given in the section below illustrates the use of <b>refines type</b> to provide mappings of 
ports 
to source text variable names in different component implementations.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>Properties are predefined for each of the component categories 
and will be described in the 
appropriate sections. See Section 10.3 regarding rules for determining property values.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>NOTES:</span></font><span></span></div>
<div align="left"><font face="Helvetica" size="1"><span style="font-size:9pt">Component implementation 
declarations can only refer to component types residing in the same 
package namespace. In order to add an implementation to a component type declared in another 
package, the component type can be created in the current namespace (package) by referencing the 
original package in a type extension in the current namespace.&#160; In the following example, LM::GPS 
is a 
reference to the original type defined in the package LM.</span></font><span></span></div>
<div align="left"><font face="Helvetica" size="1"><span style="font-size:9pt"><b>&#160;&#160;&#160;&#160;&#160;&#160;system</b>GPS <b>extends</b> 
LM::GPS <b>end</b> GPS;</span></font><span></span></div>
<div align="center"><font face="Helvetica"><span><i>Processing Requirements and Permissions</i></span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>A component implementation denotes a set of physical 
system components, existing or potential, 
that are compliant with the component implementation declaration as well as the associated 
component type.&#160; That is, the physical components denoted by a component implementation 
declaration are always compliant with the functional interface specified by the associated 
component type declaration.&#160; Physical components denoted by different implementations for the 
same component type differ in additional details such as internal structure or behaviors; these 
differences may be specified using properties.</span></font><span></span></div>
<div align="left"><font face="Helvetica"><span>In general, two physical components that comply with 
the same component type and component 
implementation are not necessarily substitutable for each other in a physical system.&#160; This is 
because an AADL specification may be legal but not specify all of the characteristics that are 
required to insure total correctness of a final assembled system.&#160; For example, two different 
versions of a piece of source text might both comply with the same AADL specification, yet one of 
them may contain a programming defect that results in unacceptable runtime behavior. Compliance 
with this standard alone is not sufficient to guarantee overall correctness of a physical system.&#160;</span></font><span></span></div>
<div align="center"><font face="Helvetica"><span><i>Examples</i></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>thread</b>DriverModeLogic</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>features</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b> BreakPedalPressed 
: <b>in data port</b> Bool_Type;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b> ClutchPedalPressed 
: <b>in data port</b> Bool_Type;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b> Activate : <b>in 
data port</b>Bool_Type;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b> Cancel : <b>in 
data port</b>Bool_Type;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b> OnNotOff : <b>in 
data port</b>Bool_Type;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;&#160;</b> CruiseActive : <b>out 
data port</b> Bool_Type;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>end</b>DriverModeLogic<b>;</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>-- Two implementations whose source 
texts use different variable names 
for</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>-- their cruise active port</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>thread implementation</b> DriverModeLogic.Simulink</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>refines type</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160; CruiseActive: <b>refined 
to out data port</b>Bool_Type</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160;&#160; 
{ Source_Name =&gt; &#8220;CruiseControlActive&#8221;; 
};</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>properties</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;</b>Dispatch_Protocol=&gt;Periodic;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160; Period=&gt; 10 ms;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>end</b>DriverModeLogic.Simulink<b>;</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>thread implementation</b> DriverModeLogic.C</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>refines type</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160; CruiseActive: <b>refined to 
out data port</b>Bool_Type</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160;&#160;&#160;&#160;&#160; { Source_Name 
=&gt;&#8220;CCActive&#8221;; };</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>properties</b></span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>&#160;</b>Dispatch_Protocol=&gt;Periodic;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span>&#160; Period=&gt; 10 ms;</span></font><span></span></div>
<div align="left"><font face="Courier New" color="#010101"><span><b>end</b>DriverModeLogic.C<b>;</b></span></font><span></span></div></div>




  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>
<!--END PAGE BODY ITEM-->


<!-- BEGIN TOP BUTTON -->
<tr class="topic">
  <td class="main" valign="top" colspan="2">
    <div class="body">
      <div class="topCommand">
        <span class="commands">
      <span class="command">
            <img src="Res/images/top_button.gif" alt="">
          <a href="javascript:scroll(0,0)">
             <span class="label">Top</span>
              </a>
    </span>
       </span>
      </div>
    </div>
  </td>
  <td class="right" valign="top">
<!--right body column empty-->
  </td>
</tr>
<!-- END TOP BUTTON -->

</table>

<!-- BEGIN SIDE NAVIGATION WRAPPER-->
    </td>
  </tr>
</table>
<!-- END SIDE NAVIGATION WRAPPER-->

<!-- END PAGE BODY-->


</body>
</html>

